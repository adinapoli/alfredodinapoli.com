<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" content="text/html" http-equiv="content-type" />
    <meta content="Alfredo Di Napoli - Computer Scientist, Scala and Haskell Programmer" name="title" />
    <meta content="Alfredo Di Napoli - Computer Scientist, Scala and Haskell Programmer" name="description" />
    <meta content="Alfredo Di Napoli, Di Napoli Alfredo, Haskell, C++, Python, Scala
    Programmer, Engineer, Functional, Programmatore, Roma, Web" name="keywords" />
    <meta content="alfredo.dinapoli@gmail.com" name="Author" /><meta content="global" name="distribution" />
    <meta content="document" name="resource-type" /><meta content="Alfredo Di Napoli" name="CreatedBy" />
    <meta content="General" name="RATING" />
    <meta content="all,index,follow" name="ROBOTS" />
    <meta content="15 days" name="REVISIT-AFTER" />
    <meta content="Public" name="document-type" />
    <meta content="Safe for Kids" name="document-rating" />
    <meta content="Global" name="document-distribution" />
    <meta content="internet" name="document-classification" />
    <meta content="Alfredo Di Napoli - Computer Scientist, Scala and Haskell Programmer" name="abstract" />
    <meta content="en" http-equiv="content-language" />
    <meta content="Aladin" name="robots" />
    <meta content="scooter" name="robots" />
    <meta content="Crawler" name="robots" />
    <meta content="Eule-Robot" name="robots" />
    <meta content="excite" name="robots" />
    <meta content="Flipper/1.1" name="robots" />
    <meta content="SmartCrawl" name="robots" />
    <meta content="Motor0.5" name="robots" />
    <meta content="Lycos" name="robots" />
    <meta content="Google" name="robots" />
    <meta content="Bing" name="robots" />
    <meta content="Copyright &copy; Alfredo Di Napoli - All rights reserved" name="copyright" />
    <meta content="web design, functional, haskell, scala, python, programming" name="classification" />
    <meta content="GLOBAL" name="distribution" />

    <title>Alfredo Di Napoli - Computer Scientist, Scala and Haskell Programmer</title>
    <link href="../css/bootstrap.css" rel="stylesheet" type="text/css" media="screen" />
    <link href="../css/syntax.css" rel="stylesheet" type="text/css" media="screen" />
    <link href="../css/screen.css" rel="stylesheet" type="text/css" media="screen" />
    
  </head>

  <body>
    <div class="container">
      
      <!-- start header -->
      <div id="header" class="row">

        <div class="col-5">
          <div class="col-7">
            <em class="lead">Simplicity is the ultimate sophistication.</em>
          </div>

          <div class="col-5 pull-left">
            <img src="../img/enso.png" width="100" />
          </div>
        </div>
        
        <div class="col-7">
          <div id="menu" class="pull-right">
            <a href="../index.html">Home</a> ●
            <a href="../posts.html">Blog</a> ●
            <a href="../oss.html">Projects</a> ●
            <a href="../talks.html">Talks</a> ●
            <a href="../cv_eu/cv_eu.html">CV</a> ●
            <a href="../contacts.html">Contacts</a>
          </div>
        </div>

      </div>

      <!-- end header -->
      <div class="row">
        <hr>
          <!-- content goes here -->
          <script type="text/javascript">
  var disqus_developer = 1;
</script>


<h1>Beware the defaulting</h1>

<p>Posted in: <a title="All pages tagged 'fp'." href="../tags/fp.html">fp</a>, <a title="All pages tagged 'haskell'." href="../tags/haskell.html">haskell</a>, <a title="All pages tagged 'ocaml'." href="../tags/ocaml.html">ocaml</a>.</p>
<br>
<p>It started innocently enough. I was comparing execution times (as I usually do) between different programming languages. This time was the turn of OCaml. I’ve implemented in it the usual Project Euler #5 problem, because It’s easy and computationally not too expensive. This is the OCaml implementation:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> Core.Std</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> div_pred n seq =</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">List</span>.for_all seq (<span class="kw">fun</span> x -&gt; Int.(=) (n <span class="kw">mod</span> x) <span class="dv">0</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> solver =</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> seq = <span class="dt">List</span>.range ~stride:(<span class="dv">-1</span>) <span class="dv">20</span> <span class="dv">1</span> <span class="kw">in</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux accum =</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">match</span> (div_pred accum seq) <span class="kw">with</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        | <span class="kw">true</span> -&gt; accum</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        | <span class="kw">false</span> -&gt; aux (accum + <span class="dv">20</span>)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> aux <span class="dv">20</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = <span class="dt">Printf</span>.printf <span class="st">&quot;%d&quot;</span> solver</span></code></pre></div>
<p>It’s nice and also fast:</p>
<pre><code>232792560
./euler5  0,25s user 0,01s system 97% cpu 0,275 total
</code></pre>
<p>This was an old version I implemented in Haskell, focusing on expressiveness:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>solver <span class="ot">=</span> find (\x <span class="ot">-&gt;</span> divPred x) [<span class="dv">20</span>,<span class="dv">40</span><span class="op">..</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>divPred x <span class="ot">=</span> <span class="fu">all</span> (\y <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> y <span class="op">==</span> <span class="dv">0</span>) [<span class="dv">20</span>,<span class="dv">19</span><span class="op">..</span><span class="dv">2</span>]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> solver</span></code></pre></div>
<p>Then I executed it:</p>
<pre><code>Just 232792560
./euler5  0,84s user 0,05s system 95% cpu 0,934 total</code></pre>
<p>Uhm.. 3 times slower then the OCaml version, must be the overhead introduced by list lazyness, I thought, because I’m creating an infinite list and asking to it for the next value until I find one that respect my predicate. So I said “<em>Let’s try removing the infinite list</em>” and I produced this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solver ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>solver n lst <span class="ot">=</span> <span class="kw">if</span> divPred n lst <span class="kw">then</span> n <span class="kw">else</span> solver (n <span class="op">+</span> <span class="dv">20</span>) lst</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">divPred ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>divPred x <span class="ot">=</span> <span class="fu">all</span> (\y <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> y <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> solver <span class="dv">20</span> [<span class="dv">20</span>,<span class="dv">19</span><span class="op">..</span><span class="dv">2</span>]</span></code></pre></div>
<p>I’ve also added the signature to aid the compiler with type inference. This version is slightly faster:</p>
<pre><code>232792560
./euler5  0,62s user 0,11s system 96% cpu 0,761 total</code></pre>
<p>But still slower than OCaml’s version. I was beginning to struggle with bang pattern and seq wizardry when I notices a warning by <strong>ghc-mod</strong>:</p>
<div data-align="center" data-markdown="1">
<p><br><br> Defaulting the following constraint(s) to type `Integer’ <br><br> <br><br></p>
</div>
<p>It was referring to the last list, the one in the <strong>main</strong> function. So I thought “<em>Let’s restrict it’s type to Int. After all, the Integer type allows numbers to be very huge, and you pay for this feature. Furthermore, I’m sure that my solution will be in the Int type range</em>”. This is the final version:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solver ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>solver n lst <span class="ot">=</span> <span class="kw">if</span> divPred n lst <span class="kw">then</span> n <span class="kw">else</span> solver (n <span class="op">+</span> <span class="dv">20</span>) lst</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">divPred ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>divPred x <span class="ot">=</span> <span class="fu">all</span> (\y <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> y <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> solver <span class="dv">20</span> ([<span class="dv">20</span>,<span class="dv">19</span><span class="op">..</span><span class="dv">2</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>])</span></code></pre></div>
<p>With my huge surprise, this runs as fast as the OCaml version, paying almost no overhead for the (little) lazy list:</p>
<pre><code>232792560
./euler5  0,28s user 0,02s system 99% cpu 0,305 total</code></pre>
<div data-align="center" data-markdown="1">
<p><strong>Lesson learned. Beware the defaulting.</strong></p>
</div>


<hr>
Loved this post? Stay <a href="http://www.alfredodinapoli.com/rss.xml">update</a>!
<h2><u>Comments</u></h2>
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_identifier = '/posts/2012-09-12-beware-the-defaulting.html';
  var disqus_url = 'http://www.alfredodinapoli.com' + '/posts/2012-09-12-beware-the-defaulting.html';
  var disqus_title = 'Beware the defaulting';
  (function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = 'http://adinapoli.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
   })();
</script>
 <noscript><p>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=adinapoli">comments powered by Disqus.</a></p></noscript>





          <!-- end of content -->
      </div>
    
    <!-- end of main container -->
    </div>
    
      
    

  </body>
</html>
