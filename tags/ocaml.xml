<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Alfredo Di Napoli's Tech Blog</title>
    <link href="http://www.alfredodinapoli.com/tags/ocaml.xml" rel="self" />
    <link href="http://www.alfredodinapoli.com" />
    <id>http://www.alfredodinapoli.com/tags/ocaml.xml</id>
    <author>
        <name>Alfredo Di Napoli</name>
        <email>alfredo.dinapoli@gmail.com</email>
    </author>
    <updated>2012-09-12T00:00:00Z</updated>
    <entry>
    <title>Beware the defaulting</title>
    <link href="http://www.alfredodinapoli.com/posts/2012-09-12-beware-the-defaulting.html" />
    <id>http://www.alfredodinapoli.com/posts/2012-09-12-beware-the-defaulting.html</id>
    <published>2012-09-12T00:00:00Z</published>
    <updated>2012-09-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>It started innocently enough. I was comparing execution times (as I usually do) between different programming languages. This time was the turn of OCaml. I’ve implemented in it the usual Project Euler #5 problem, because It’s easy and computationally not too expensive. This is the OCaml implementation:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> Core.Std</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> div_pred n seq =</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">List</span>.for_all seq (<span class="kw">fun</span> x -&gt; Int.(=) (n <span class="kw">mod</span> x) <span class="dv">0</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> solver =</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> seq = <span class="dt">List</span>.range ~stride:(<span class="dv">-1</span>) <span class="dv">20</span> <span class="dv">1</span> <span class="kw">in</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux accum =</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">match</span> (div_pred accum seq) <span class="kw">with</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        | <span class="kw">true</span> -&gt; accum</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        | <span class="kw">false</span> -&gt; aux (accum + <span class="dv">20</span>)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> aux <span class="dv">20</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = <span class="dt">Printf</span>.printf <span class="st">&quot;%d&quot;</span> solver</span></code></pre></div>
<p>It’s nice and also fast:</p>
<pre><code>232792560
./euler5  0,25s user 0,01s system 97% cpu 0,275 total
</code></pre>
<p>This was an old version I implemented in Haskell, focusing on expressiveness:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>solver <span class="ot">=</span> find (\x <span class="ot">-&gt;</span> divPred x) [<span class="dv">20</span>,<span class="dv">40</span><span class="op">..</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>divPred x <span class="ot">=</span> <span class="fu">all</span> (\y <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> y <span class="op">==</span> <span class="dv">0</span>) [<span class="dv">20</span>,<span class="dv">19</span><span class="op">..</span><span class="dv">2</span>]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> solver</span></code></pre></div>
<p>Then I executed it:</p>
<pre><code>Just 232792560
./euler5  0,84s user 0,05s system 95% cpu 0,934 total</code></pre>
<p>Uhm.. 3 times slower then the OCaml version, must be the overhead introduced by list lazyness, I thought, because I’m creating an infinite list and asking to it for the next value until I find one that respect my predicate. So I said “<em>Let’s try removing the infinite list</em>” and I produced this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solver ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>solver n lst <span class="ot">=</span> <span class="kw">if</span> divPred n lst <span class="kw">then</span> n <span class="kw">else</span> solver (n <span class="op">+</span> <span class="dv">20</span>) lst</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">divPred ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>divPred x <span class="ot">=</span> <span class="fu">all</span> (\y <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> y <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> solver <span class="dv">20</span> [<span class="dv">20</span>,<span class="dv">19</span><span class="op">..</span><span class="dv">2</span>]</span></code></pre></div>
<p>I’ve also added the signature to aid the compiler with type inference. This version is slightly faster:</p>
<pre><code>232792560
./euler5  0,62s user 0,11s system 96% cpu 0,761 total</code></pre>
<p>But still slower than OCaml’s version. I was beginning to struggle with bang pattern and seq wizardry when I notices a warning by <strong>ghc-mod</strong>:</p>
<div data-align="center" data-markdown="1">
<p><br><br> Defaulting the following constraint(s) to type `Integer’ <br><br> <br><br></p>
</div>
<p>It was referring to the last list, the one in the <strong>main</strong> function. So I thought “<em>Let’s restrict it’s type to Int. After all, the Integer type allows numbers to be very huge, and you pay for this feature. Furthermore, I’m sure that my solution will be in the Int type range</em>”. This is the final version:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solver ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>solver n lst <span class="ot">=</span> <span class="kw">if</span> divPred n lst <span class="kw">then</span> n <span class="kw">else</span> solver (n <span class="op">+</span> <span class="dv">20</span>) lst</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">divPred ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>divPred x <span class="ot">=</span> <span class="fu">all</span> (\y <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> y <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> solver <span class="dv">20</span> ([<span class="dv">20</span>,<span class="dv">19</span><span class="op">..</span><span class="dv">2</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>])</span></code></pre></div>
<p>With my huge surprise, this runs as fast as the OCaml version, paying almost no overhead for the (little) lazy list:</p>
<pre><code>232792560
./euler5  0,28s user 0,02s system 99% cpu 0,305 total</code></pre>
<div data-align="center" data-markdown="1">
<p><strong>Lesson learned. Beware the defaulting.</strong></p>
</div>]]></summary>
</entry>

</feed>
