<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Alfredo Di Napoli's Tech Blog</title>
    <link href="http://www.alfredodinapoli.com/tags/type-families.xml" rel="self" />
    <link href="http://www.alfredodinapoli.com" />
    <id>http://www.alfredodinapoli.com/tags/type-families.xml</id>
    <author>
        <name>Alfredo Di Napoli</name>
        <email>alfredo.dinapoli@gmail.com</email>
    </author>
    <updated>2014-10-13T00:00:00Z</updated>
    <entry>
    <title>Fun with Dependent Types in Haskell</title>
    <link href="http://www.alfredodinapoli.com/posts/2014-10-13-fun-with-dependent-types-in-haskell.html" />
    <id>http://www.alfredodinapoli.com/posts/2014-10-13-fun-with-dependent-types-in-haskell.html</id>
    <published>2014-10-13T00:00:00Z</published>
    <updated>2014-10-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Inspired by recent <a href="https://skillsmatter.com/skillscasts/5356-oliver-charles">Oliver Charles’ talk</a> at the Haskell Xchange (which was a blast, btw), I felt compelled in trying to fiddle around with type families and dependent types in Haskell to fix the concepts in my long term memory. Even though those weren’t new to me, and Ollie’s talk was very accessible and nicely delivered, I wanted to brainstorm a bit to see what I could get out of it. First of all I read the <a href="http://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf">suggested paper</a>, which was a really nice refresher on the topic (and much more!). <strong>This is a literate Haskell post. Feel free to load it inside GHCi</strong>. First a bit of throat-clearing:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span></code></pre></div>
<p>In this post we’ll index our datatypes by lifted naturals instead of lifted Peano number, so we leverage the handy <code>GHC.TypeLits</code> module:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span></code></pre></div>
<p>Let’s first start with something simple: In case you need a quick reminder, a <code>type family</code> is essentially a function <em>at the type level</em>. Let’s write the <code>SillyId</code> type family: it will take a type and will return the type itself:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">SillyID</span><span class="ot"> k1 ::</span> <span class="op">*</span></span></code></pre></div>
<p>Here we are using an <em>open type family</em>, as we can see from the following instances:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">SillyID</span> <span class="dt">Bool</span> <span class="ot">=</span> <span class="dt">Bool</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">SillyID</span> <span class="dt">Int</span> <span class="ot">=</span> <span class="dt">Int</span></span></code></pre></div>
<p>In a nutshell we are mapping these two types to themselves. Think as a sort of <code>id</code>, but at the type level. We can “use” a type family in a function signature to transform types:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sillyBool ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">SillyID</span> <span class="dt">Bool</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>sillyBool <span class="dt">True</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>sillyBool <span class="dt">False</span> <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>So far this should be very basic and boring stuff. Let’s move over.</p>
<h1 id="type-safe-byte-chunks">Type safe byte chunks</h1>
<p>To motivate this blog post, let’s imagine your boss asked you to write a program to handle chunks of raw bytes. As every good Haskeller you like types and would like to write your program in a way that the invariant are specified in the types. Your first thought is to model a chunk as a vector, and almost unconsciously you write something like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Chunk</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">CNil</span><span class="ot"> ::</span> <span class="dt">Chunk</span> <span class="dv">0</span> a</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:*:) ::</span> a <span class="ot">-&gt;</span> <span class="dt">Chunk</span> n a <span class="ot">-&gt;</span> <span class="dt">Chunk</span> (n <span class="op">+</span> <span class="dv">1</span>) a</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:*:</span></span></code></pre></div>
<p>The <code>TypeLits</code> module we imported promotes every natural into a type, allowing us to write this extremely nice vector. It also promotes some operations for naturals as well, so that we can simply express the increment in size of our <code>:*:</code> operator as <code>Chunk (n + 1) a</code>. This doesn’t give us much more than standard vectors though: we could still write, for example, the following:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unsafeHead ::</span> <span class="dt">Chunk</span> n a <span class="ot">-&gt;</span> a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>unsafeHead <span class="dt">CNil</span> <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Ops!&quot;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>unsafeHead (x <span class="op">:*:</span> _) <span class="ot">=</span> x</span></code></pre></div>
<p>Uhm, this is not Haskell-y! Let’s fix this first. What we need is a way to force the compiler to reject a function like this which is applied to an empty <code>Chunk</code>. There are tons of ways to solve this, so we’ll pick just one solution for didactic purposes. Let’s first write another type family, but these time a <em>closed</em> one: this has the nice advantage to give us the control in a way that we cannot add more cases externally (as orphans):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">NonZero</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NonZero</span> x <span class="ot">=</span> _</span></code></pre></div>
<p>What we can write inside the <em>hole</em>? This will certainly work:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">NonZero</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NonZero</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NonZero</span> x <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>If you are not familiar with type families this is a type-level function which is expecting a <code>Nat</code> and will return a <code>Bool</code>: what we see there, though, are not types but <strong>kinds</strong> (remember: everything is lifted one level up). This is why we return <code>True</code> or <code>False</code>, which are two promoted values into the type level (this is what the <code>DataKinds</code> extension is for). If you want to visually enforce the value/type separation, you can prepend each promoted datatype with a <code>'</code>, which can be omitted when there is no ambiguity. To write the version of <code>NonZero</code> we’ll use, let’s start from the intuition: we would like to <em>compare</em> the input <code>Nat</code> with <code>0</code>, to assess whether they are equal or different (being naturals we do not have to worry about negative numbers). It turns out that <code>GHC.TypeLits</code> already have exactly what we need:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">CmpSymbol</span> m<span class="ot"> n ::</span> <span class="dt">Ordering</span></span></code></pre></div>
<p>Unfortunately this yields an <code>Ordering</code>, but what we want is a <code>Bool</code>, so we need a type level function from <code>Ordering -&gt; Bool</code>. Let’s try this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">EqualTo</span> (<span class="ot">n ::</span> <span class="dt">Ordering</span>) (<span class="ot">m ::</span> <span class="dt">Ordering</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EqualTo</span> <span class="dt">GT</span> <span class="dt">GT</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EqualTo</span> <span class="dt">LT</span> <span class="dt">LT</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EqualTo</span> <span class="dt">EQ</span> <span class="dt">EQ</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EqualTo</span> x y <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>Nice. Armed with this, we can write our <code>NonZero</code> type family:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">NonZero</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NonZero</span> x <span class="ot">=</span> <span class="dt">EqualTo</span> (<span class="dt">CmpNat</span> <span class="dv">0</span> x) <span class="dt">LT</span></span></code></pre></div>
<p>And finally write a <code>safeHead</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">safeHead ::</span> <span class="dt">NonZero</span> n <span class="op">~</span> <span class="dt">True</span> <span class="ot">=&gt;</span> <span class="dt">Chunk</span> n <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>safeHead (x <span class="op">:*:</span> _) <span class="ot">=</span> x</span></code></pre></div>
<p>The novelty here is just that we used type level equality to basically say: "Please GHC, I want this function to be called only on types where the constrain <code>NonZero ~ True</code> holds. You can think of <code>~</code> as an equal sign. To give you the intuition the type level function needs to yield <code>True</code> at compile type for this function to typecheck.</p>
<p>This will compile:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">safe1 ::</span> <span class="dt">Chunk</span> <span class="dv">1</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>safe1 <span class="ot">=</span> safeHead</span></code></pre></div>
<p>But this won’t:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unsafe1 ::</span> <span class="dt">Chunk</span> <span class="dv">0</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>unsafe1 <span class="ot">=</span> safeHead</span></code></pre></div>
<p>Ok, this was a lot of work for a simple total function, but it paved the way for more interesting stuff!</p>
<h1 id="more-interesting-stuff">More interesting stuff</h1>
<p>Your boss looks at your code and says “Ok, but this stuff can be done in Idris or Agda in few lines of code. Not impressed.”, so you go back to your desk and keep coding. The new requirement is to write a function which operates on byte chunks. So we want to write a function where only chunks which are <em>multiple of 8</em> are allowed to typecheck. In a non-dependently typed world, a Java programmer would write:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">static</span> MultipleOf8 <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span> Int <span class="fu">multOf8</span><span class="op">(</span>Chunk<span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> chunk<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">!(</span><span class="fu">multOf</span><span class="op">(</span><span class="dv">8</span><span class="op">,</span> chunk<span class="op">.</span><span class="fu">length</span><span class="op">())</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>      <span class="cf">throw</span> <span class="fu">NotMultipleOf8Exception</span><span class="op">(</span>chunk<span class="op">)</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// do stuff</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> chunk<span class="op">.</span><span class="fu">head</span><span class="op">();</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>As Haskellers, we might try to do better than the imperative version and wrap the possibly-failing computation in a monad:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Positive multiple of, classic Haskell inductive function</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="ot">posMultOf ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>posMultOf _ <span class="dv">0</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>posMultOf x y <span class="ot">=</span> <span class="kw">if</span> y <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">False</span> <span class="kw">else</span> posMultOf x (y <span class="op">-</span> x)</span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">chunkLen ::</span> <span class="dt">Chunk</span> n a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>chunkLen <span class="dt">CNil</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>chunkLen (_ <span class="op">:*:</span> xs) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> chunkLen xs</span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">multOf8Mb ::</span> <span class="dt">Chunk</span> n <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>multOf8Mb <span class="dt">CNil</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>multOf8Mb c<span class="op">@</span>(x <span class="op">:*:</span> _) <span class="ot">=</span> <span class="kw">case</span> posMultOf <span class="dv">8</span> (chunkLen c) <span class="kw">of</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> x</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>We could certainly use <code>NonZero</code> to avoid the <code>CNil</code> equation, but this is not very satisfying anyway: wouldn’t be nice to enforce the invariant of “must be multiple of 8” into the type system? What we really want is a “type level posMultOf” function, something which will yield a type-level <code>Bool</code>. Let’s look again at the definition:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">posMultOf ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>posMultOf _ <span class="dv">0</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>posMultOf x y <span class="ot">=</span> <span class="kw">if</span> y <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">False</span> <span class="kw">else</span> posMultOf x (y <span class="op">-</span> x)</span></code></pre></div>
<p>First equation is easy. Second equation has a couple of pain points: * We need to do arithmetic (i.e. <code>y - x</code>) * We need to do conditional branching * We need comparison (i.e. y &lt; 0)</p>
<p>Luckily we can address the first point thanks, once again, to <code>TypeLits</code>, which gives us, out of the box, exactly this. But now we need a <em>type level if function</em>. Can we write it? It is surprising easy to do so!</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">If</span> (<span class="fu">pred</span><span class="ot"> ::</span> <span class="dt">Bool</span>) (<span class="ot">thenB ::</span> <span class="dt">Bool</span>) (<span class="ot">elseB ::</span> <span class="dt">Bool</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">If</span> <span class="dt">True</span> t r <span class="ot">=</span> t</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">If</span> <span class="dt">False</span> t r <span class="ot">=</span> r</span></code></pre></div>
<p>Nice! What about the last one? We need <code>y &lt; 0</code> but all we can do at the moment is say <code>y is non negative</code>, but here we need <code>y is negative</code>. Did you guess already? We need a type-level <code>not</code> function!</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Not</span> (<span class="ot">b ::</span> <span class="dt">Bool</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Not</span> <span class="dt">&#39;True</span> <span class="ot">=</span> <span class="dt">&#39;False</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Not</span> <span class="dt">&#39;False</span> <span class="ot">=</span> <span class="dt">&#39;True</span></span></code></pre></div>
<p>And finally we can express <code>PosMultOf</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">PosMultOf</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PosMultOf</span> x <span class="dv">0</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PosMultOf</span> x y <span class="ot">=</span> <span class="dt">If</span> (<span class="dt">Not</span> (<span class="dt">NonZero</span> y)) <span class="dt">False</span> (<span class="dt">PosMultOf</span> x (y <span class="op">-</span> x))</span></code></pre></div>
<p>Which I find remarkable: Look at how similar is to the value-level one!</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">posMultOf ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>posMultOf _ <span class="dv">0</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>posMultOf x y <span class="ot">=</span> <span class="kw">if</span> y <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">False</span> <span class="kw">else</span> posMultOf x (y <span class="op">-</span> x)</span></code></pre></div>
<p>Armed with this, we can now write:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">multOf8 ::</span> (<span class="dt">NonZero</span> n <span class="op">~</span> <span class="dt">True</span>, <span class="dt">PosMultOf</span> <span class="dv">8</span> n <span class="op">~</span> <span class="dt">True</span>) <span class="ot">=&gt;</span> <span class="dt">Chunk</span> n <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>multOf8 (x <span class="op">:*:</span> _) <span class="ot">=</span> x</span></code></pre></div>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">correct ::</span> <span class="dt">Chunk</span> <span class="dv">8</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>correct <span class="ot">=</span> multOf8</span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">correct&#39;&#39; ::</span> <span class="dt">Chunk</span> <span class="dv">16</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>correct&#39;&#39; <span class="ot">=</span> multOf8</span></code></pre></div>
<p>As expected, these won’t typecheck:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">emptyChunk ::</span> <span class="dt">Chunk</span> <span class="dv">0</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>emptyChunk <span class="ot">=</span> multOf8</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="ot">bogus ::</span> <span class="dt">Chunk</span> <span class="dv">7</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>bogus <span class="ot">=</span> multOf8</span></code></pre></div>
<p>Nice!</p>
<h1 id="conclusions">Conclusions</h1>
<p>Harnessing dependently types techniques in Haskell is easy (not as easy as Idris or Agda though), fun, and yield code with stronger safety guarantees. Mastering type families takes a while, but is definitely worthwhile!</p>
<h1 id="acknowledgements">Acknowledgements</h1>
<ul>
<li>Oliver Charles for the nice talk</li>
<li>Richard A. Eisenberg and Stephanie Weirich for the nice paper</li>
<li>You, the reader, for reading it till the end.</li>
</ul>]]></summary>
</entry>

</feed>
