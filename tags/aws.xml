<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Alfredo Di Napoli's Tech Blog</title>
    <link href="http://www.alfredodinapoli.com/tags/aws.xml" rel="self" />
    <link href="http://www.alfredodinapoli.com" />
    <id>http://www.alfredodinapoli.com/tags/aws.xml</id>
    <author>
        <name>Alfredo Di Napoli</name>
        <email>alfredo.dinapoli@gmail.com</email>
    </author>
    <updated>2017-03-16T00:00:00Z</updated>
    <entry>
    <title>Deploying Haskell on AWS Lambda</title>
    <link href="http://www.alfredodinapoli.com/posts/2017-03-16-deploying-haskell-on-aws-lambda.html" />
    <id>http://www.alfredodinapoli.com/posts/2017-03-16-deploying-haskell-on-aws-lambda.html</id>
    <published>2017-03-16T00:00:00Z</published>
    <updated>2017-03-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Originally published in IRIS Connect’s <a href="http://engineers.irisconnect.net/posts/2017-03-16-deploying-haskell-on-aws-lambda.html">Engineering blog</a>.</p>
<h2 id="background">Background</h2>
<p>At work I was put on a new project involving a low-volume application where a customer would upload some CSV files inside an <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/Welcome.html">S3</a> bucket, and this event would trigger some sort of server-side computation, to parse and validate the CSV files and produce some output. As soon as I looked at the requirements, <a href="https://aws.amazon.com/lambda/">AWS Lamba</a> came to mind, especially because we didn’t want to maintain a server infrastructure due to the nature of the project. What tipped the scale was the fact AWS supports Lambda as one of the <a href="https://aws.amazon.com/blogs/aws/s3-event-notification/">notification mediums</a> to respond to an S3 event; upon seeing that my mind was set!</p>
<p>In a nutshell, this is the flow of the app:</p>
<div class="figure text-center">
<img src="https://media.amazonwebservices.com/blog/2014/s3_notification_flow_2.png" alt="Image courtesy of Amazon">
<p class="caption">
Image courtesy of Amazon
</p>
</div>
<p><br></p>
<p>AWS Lambda is capable of running any binary, as long as it’s statically linked and compiled for x86 Linux, but at the same time it doesn’t offer first-class support for Haskell, but it’s possible to spawn an external process via the Node.js API. So the trick is to:</p>
<ul>
<li>Use Docker to generate a Linux executable</li>
<li>Create a JS Shim to spawn a process calling our executable</li>
<li>Bundle everything into a zip file (including 3rd party dependencies)</li>
<li>Upload to AWS Lambda</li>
<li>Watch out for any pitfalls</li>
</ul>
<p>Needless to say that we need the Docker step because we are working on an OSX machine, whilst targeting Linux. Cross-compiling GHC for Linux is a bit of a pain, so it’s definitely way quicker to use Docker.</p>
<h3 id="optional-step-reduce-the-size-of-the-output-binary">(Optional step) Reduce the size of the output binary</h3>
<p>When I was working remotely from my parent’s house in Rome, I did have at my disposal only a humble domestic DSL connection, and definitely every byte mattered when it came to transfer data from my laptop into S3. This is why I’ve got into the habit of compressing my executables with <a href="https://upx.github.io/">UPX</a>. The rest of the post takes that into the account, but note how such compression step is not required to deploy on AWS Lambda.</p>
<h2 id="use-docker-to-generate-a-linux-executable">Use Docker to generate a Linux executable</h2>
<p>We can use a script from the process <a href="http://www.alfredodinapoli.com/posts/2015-11-03-how-i-deploy-haskell-code.html">outlined</a> in my personal blog. It basically creates a new Docker Image called “ghc-linux-6.5-builder” using <code>Build.plan</code> as the Docker file. <code>Build.plan</code> itself is quite simple:</p>
<pre class="shell"><code>FROM fpco/stack-build:lts-6.5

ADD .  /usr/lib/haskell
WORKDIR /usr/lib/haskell
USER root
# Pass SSH_KEY as argument.
ARG SSH_KEY

# Specify a specific private key.
RUN echo &quot;    IdentityFile /root/.ssh/id_rsa&quot; &gt;&gt; /etc/ssh/ssh_config

# Skip host verification for GitHub
RUN echo &quot;Host github.com\n\tStrictHostKeyChecking no\n&quot; &gt;&gt; /etc/ssh/ssh_config

# Create SSH_KEY inside container.
RUN echo &quot;$SSH_KEY&quot; &gt;&gt; /root/.ssh/id_rsa

# Give private key correct permissions.
RUN chmod 0600 /root/.ssh/id_rsa
# Give private key correct permissions.
RUN chmod 0600 /root/.ssh/id_rsa

CMD [&quot;stack&quot;]</code></pre>
<p>We are starting from the <code>lts-6.5</code> Docker image FPComplete is providing us (which already includes all the system libraries that all the LTS 6.5 deps will need to link against) plus adding our own <code>.ssh/id_rsa</code> to make sure we can clone stuff from GitHub (this passage is optional and should only be required if we clone stuff from private repositories). Note that we are using a somewhat outdated LTS revision as with newer ones using GHC 8 I was getting an error whilst installing GHC (seemed a problem related to the toolchain), which unfortunately I didn’t have time to investigate further. Once everything has built correctly, we can simply alias <code>stack-linux</code> to be an invocation of the <code>stack</code> command via this newly built Docker image:</p>
<pre class="shell"><code>
#!/usr/bin/env bash

eval $(docker-machine env)

docker run --rm \
       -v $PWD/linux-dist:/root/.local \
       -v $PWD/.stack-work:/usr/lib/haskell/.stack-work \
       -v $HOME/.stack:/root/.stack \
       ghc-linux-6.5-builder:latest stack --allow-different-user $@</code></pre>
<p>You can see we are targeting an OSX machine, due to the call to <code>docker-machine</code>. Mapping host directories like <code>$HOME/.stack</code> will also ensure we will be caching packages built from one invocation to the other, making the process much quicker overall. So, to summarise, when we call <code>build_linux</code> what really happens is that we are first creating the new Docker image (or updating it), and finally calling <code>stack-linux install</code> as we would normally do on our local machine, but the cool thing here is that the build is going to happen on the <em>Docker container</em> and due to the fact we mounted the output of the install to <code>linux-dist</code> on our local machine, at the end of the process we will have a nice Linux binary ready to be deployed on AWS Lambda!</p>
<p>Here is how <code>build_linux.sh</code> is structured:</p>
<pre class="shell"><code>#!/usr/bin/env bash

eval $(docker-machine env)

docker build --build-arg SSH_KEY=&quot;$(cat ~/.ssh/id_rsa)&quot; -t ghc-linux-6.5-builder -f Build.plan .

./bin/stack-linux install
upx linux-dist/bin/ma-csv-proc</code></pre>
<p>After everything ran successfully, we have our final executable ready to be deployed:</p>
<pre class="shell"><code>☁  mathematica-csv-processor [issue-4] du -h linux-dist/bin/ma-csv-proc
2.6M    linux-dist/bin/ma-csv-proc</code></pre>
<p>So <code>2.6MB</code> is not bad at all for a full Haskell app which deserialise JSON from the network and parse CSV files!</p>
<h2 id="create-a-js-shim-the-main-handler">Create a JS Shim (the Main Handler)</h2>
<p>In order for AWS Lambda to run our code, we need an entrypoint, which we cannot write in Haskell as AWS Lambda doesn’t have first-class support for it. What we can do, though, is to create one using JavaScript and Node, and use the <a href="https://nodejs.org/api/child_process.html">Node.js process API</a> to spawn our executable:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> spawn <span class="op">=</span> <span class="pp">require</span>(<span class="st">&#39;child_process&#39;</span>)<span class="op">.</span><span class="at">spawn</span><span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>exports<span class="op">.</span><span class="at">handler</span> <span class="op">=</span> <span class="kw">function</span>(<span class="bu">event</span><span class="op">,</span> context) {</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">process</span><span class="op">.</span><span class="at">env</span>[<span class="st">&#39;PATH&#39;</span>] <span class="op">=</span> <span class="bu">process</span><span class="op">.</span><span class="at">env</span>[<span class="st">&#39;PATH&#39;</span>] <span class="op">+</span> <span class="st">&#39;:&#39;</span> <span class="op">+</span> <span class="bu">process</span><span class="op">.</span><span class="at">env</span>[<span class="st">&#39;LAMBDA_TASK_ROOT&#39;</span>]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">process</span><span class="op">.</span><span class="at">env</span>[<span class="st">&#39;LD_LIBRARY_PATH&#39;</span>] <span class="op">=</span> <span class="bu">process</span><span class="op">.</span><span class="at">env</span>[<span class="st">&#39;LAMBDA_TASK_ROOT&#39;</span>]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> main <span class="op">=</span> <span class="fu">spawn</span>(<span class="st">&#39;./ma-csv-proc&#39;</span><span class="op">,</span> { <span class="dt">stdio</span><span class="op">:</span> [<span class="st">&#39;pipe&#39;</span><span class="op">,</span> <span class="st">&#39;pipe&#39;</span><span class="op">,</span> <span class="bu">process</span><span class="op">.</span><span class="at">stderr</span>] })<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    main<span class="op">.</span><span class="at">stdout</span><span class="op">.</span><span class="fu">on</span>(<span class="st">&#39;data&#39;</span><span class="op">,</span> <span class="kw">function</span>(data) {</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(data<span class="op">.</span><span class="fu">toString</span>())<span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        context<span class="op">.</span><span class="fu">done</span>(<span class="kw">null</span><span class="op">,</span> data<span class="op">.</span><span class="fu">toString</span>())<span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    main<span class="op">.</span><span class="fu">on</span>(<span class="st">&#39;close&#39;</span><span class="op">,</span> <span class="kw">function</span>(code) {</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&#39;child process pipes closed with code &#39;</span><span class="op">+</span> code)<span class="op">;</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        context<span class="op">.</span><span class="fu">done</span>(<span class="kw">null</span><span class="op">,</span> code)<span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    main<span class="op">.</span><span class="fu">on</span>(<span class="st">&#39;exit&#39;</span><span class="op">,</span> <span class="kw">function</span>(code){</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(<span class="st">&#39;exit: &#39;</span> <span class="op">+</span> code)<span class="op">;</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        context<span class="op">.</span><span class="fu">done</span>(<span class="kw">null</span><span class="op">,</span> code)<span class="op">;</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    main<span class="op">.</span><span class="fu">on</span>(<span class="st">&#39;error&#39;</span><span class="op">,</span> <span class="kw">function</span>(err) {</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(<span class="st">&#39;error: &#39;</span> <span class="op">+</span> err)<span class="op">;</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        context<span class="op">.</span><span class="fu">done</span>(<span class="kw">null</span><span class="op">,</span> err)<span class="op">;</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    main<span class="op">.</span><span class="at">stdin</span><span class="op">.</span><span class="fu">write</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>({</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;event&#39;</span><span class="op">:</span> <span class="bu">event</span><span class="op">,</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;context&#39;</span><span class="op">:</span> context</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>    }) <span class="op">+</span> <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>)<span class="op">;</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Note something important: we are passing the <code>event</code> and the <code>context</code> that AWS sends us as a JSON into the stdin of our Haskell app. This ensure we can deserialise it on the Haskell side and grab the event AWS sent us, so we can react to it:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Aeson</span> <span class="kw">as</span> <span class="dt">JSON</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RawInput</span> <span class="ot">=</span> <span class="dt">RawInput</span> {</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="ot">    event   ::</span> <span class="dt">JSON.Value</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> context ::</span> <span class="dt">JSON.Value</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>deriveFromJSON defaultOptions &#39;<span class="dt">&#39;RawInput</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Result</span> <span class="ot">=</span> <span class="dt">Either</span> <span class="dt">MathematicaException</span> ()</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>  raw <span class="ot">&lt;-</span> T.hGetLine stdin</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> JSON.eitherDecode (toS raw) <span class="kw">of</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span> e                 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>      <span class="fu">putStrLn</span> <span class="st">&quot;Error reading Lambda input.&quot;</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>      <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Input was &quot;</span> <span class="op">&lt;&gt;</span> toS raw</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>      <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Error was &quot;</span> <span class="op">&lt;&gt;</span> e</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>      exitFailure</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> (<span class="ot">ri ::</span> <span class="dt">RawInput</span>) <span class="ot">-&gt;</span> <span class="co">-- Do stuff</span></span></code></pre></div>
<h2 id="bundle-everything-into-a-zip-file-including-3rd-party-deps">Bundle everything into a zip file (including 3rd party deps)</h2>
<p>Lambdas are running (as you would expect) in a sandboxed environment, so it comes as no surprise they don’t have all the executables you might need during your program’s execution. But not all is lost, as it’s entirely possible to ship them as part of the final .zip we’ll deploy. The only 2 constraints is that they should be self-contained (statically linked or otherwise) and built for Linux x86. Believe it or not Lambda doesn’t come with the excellent <a href="https://aws.amazon.com/cli/">aws-cli</a>, installed by default, so I had to package it (running it is not a problem as AWS Lambda uses IAM roles so permissioning is taken care of automatically). There is <a href="https://alestic.com/2016/11/aws-lambda-awscli/">an excellent post</a> about bundling <code>aws-cli</code> for AWS Lambda so I will simply redirect there for completeness.</p>
<p>Once we have everything we need, we can simply run a simple script to bundle everything up:</p>
<pre class="shell"><code>#!/usr/bin/env bash

mkdir -p deploy/aws-lambda/artifacts
rm -rf deploy/aws-lambda/artifacts/*
cd deploy/aws-lambda
zip -r -j artifacts/mathematica-csv-processor.zip Main.js aws ../../linux-dist/bin/ma-csv-proc

# Add aws stuff
zip -ur artifacts/mathematica-csv-processor.zip aws-cli
cd ../..</code></pre>
<p>It’s very important to run the first command with <code>-j</code> which will “squash” relative paths and will ensure the binary and the JS entrypoint will be at the top level of the zip file, which is required by AWS Lambda in order to access our code correctly. Now the fun part, deploying!</p>
<h2 id="upload-to-aws-lambda">Upload to AWS Lambda</h2>
<p>Uploading to AWS Lambda is quite simple. All is needed is for the user to create a new Lambda and then upload the zip file, either from S3 or from a web form:</p>
<p><img src="https://cloud.githubusercontent.com/assets/442035/23542521/f168633a-ffed-11e6-9c05-123f36f01e6d.png" /></p>
<h2 id="pitfalls">Pitfalls</h2>
<p>After deploying a new revision of the app, I was presented with a quite laconic error in the CloudWatch logs:</p>
<pre class="shell"><code>c_poll: Permission Denied</code></pre>
<p>There seems to be <a href="https://github.com/commercialhaskell/stack/issues/2194">a few</a> <a href="https://github.com/begriffs/postgrest/issues/566">issues</a> mentioning it explicitly, and none of them explaining what’s going on. It seems to be <a href="https://ghc.haskell.org/trac/ghc/ticket/8089?cversion=0&amp;cnum_hist=2">a GHC bug</a>, but I’m not 100% sure (as that trac ticket claims is fixed). What’s sure is that <code>c_poll</code> is coming from GHC. Luckily for me, in order to “fix” the problem, it was sufficient to simply allocate more memory for my lambda, or increase the timeout for the program execution. With 256/512 MB I was able to comfortably running my code under 10 seconds.</p>
<h2 id="credits">Credits</h2>
<p>More of the information I present here are not novel; I have shamelessly stolen ideas and concepts from these two excellent resources:</p>
<ul>
<li><a href="https://github.com/abailly/aws-lambda-haskell">https://github.com/abailly/aws-lambda-haskell</a></li>
<li><a href="https://www.agileand.me/haskell-aws-lambda/">https://www.agileand.me/haskell-aws-lambda/</a></li>
</ul>]]></summary>
</entry>

</feed>
