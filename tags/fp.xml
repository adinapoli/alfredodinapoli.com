<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Alfredo Di Napoli's Tech Blog</title>
    <link href="http://www.alfredodinapoli.com/tags/fp.xml" rel="self" />
    <link href="http://www.alfredodinapoli.com" />
    <id>http://www.alfredodinapoli.com/tags/fp.xml</id>
    <author>
        <name>Alfredo Di Napoli</name>
        <email>alfredo.dinapoli@gmail.com</email>
    </author>
    <updated>2017-05-06T00:00:00Z</updated>
    <entry>
    <title>About MonadBaseControl</title>
    <link href="http://www.alfredodinapoli.com/posts/2017-05-06-about-monadcontrolio.html" />
    <id>http://www.alfredodinapoli.com/posts/2017-05-06-about-monadcontrolio.html</id>
    <published>2017-05-06T00:00:00Z</published>
    <updated>2017-05-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This is a literate Haskell post. You can play with the examples in ghci, in a stack playground, calling:</p>
<pre><code>stack ghci --package transformers --package transformers-base --package monad-control --package distributed-process --package distributed-process-monad-control</code></pre>
<p>Let’s start with some imports:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Base</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.State</span> <span class="kw">hiding</span> (<span class="dt">StateT</span>, runStateT, execStateT, evalStateT, get)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans.Control</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans.State.Strict</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Distributed.Process</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Distributed.Process.MonadBaseControl</span></span></code></pre></div>
<p>Consider this monad:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Ctx</span> <span class="ot">=</span> <span class="dt">Ctx</span> () <span class="co">-- some kind of env, not important.</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">RemotePure</span> m a <span class="ot">=</span> <span class="dt">RemotePure</span> {<span class="ot"> runRemote ::</span> <span class="dt">StateT</span> <span class="dt">Ctx</span> m a }</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>, <span class="dt">MonadState</span> <span class="dt">Ctx</span>, <span class="dt">MonadIO</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">RemoteM</span> <span class="ot">=</span> <span class="dt">RemotePure</span> <span class="dt">Process</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadBase</span> <span class="dt">IO</span> (<span class="dt">RemotePure</span> <span class="dt">Process</span>) <span class="kw">where</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  liftBase <span class="ot">=</span> <span class="dt">RemotePure</span> <span class="op">.</span> liftBase</span></code></pre></div>
<p>You now would like to write an instance for <a href="https://hackage.haskell.org/package/monad-control-1.0.0.5/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl">MonadBaseControl</a>.</p>
<p>This is the definition of <code>MonadBaseControl</code> and <code>RunInBase</code> (at the time of writing, April 2017):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">MonadBase</span> b m <span class="ot">=&gt;</span> <span class="dt">MonadBaseControl</span> b m <span class="op">|</span> m <span class="ot">-&gt;</span> b <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">StM</span> m<span class="ot"> a ::</span> <span class="op">*</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    liftBaseWith ::</span> (<span class="dt">RunInBase</span> m b <span class="ot">-&gt;</span> b a) <span class="ot">-&gt;</span> m a</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    restoreM ::</span> <span class="dt">StM</span> m a <span class="ot">-&gt;</span> m a</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">RunInBase</span> m b <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> m a <span class="ot">-&gt;</span> b (<span class="dt">StM</span> m a)</span></code></pre></div>
<p>A legitimate question is: how can I write the correct right hand side for <code>StM</code>? As you might know, when the <code>type</code> keyword is being used in a type class definition we are not dealing with a <em>type synonym</em> but with a <em>type family</em>. A <em>type family</em> is essentially a function with operates on <em>types</em>, not <em>values</em>, like “normal” functions. But how can I pick the correct RHS? How would I know? There are two approaches: one seems to be the most popular, but it requires the use of <code>UndecidableInstances</code>, the other was found in this small nugget of <a href="http://stackoverflow.com/a/33558631/479553">wisdom</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> over at Stack Overflow.</p>
<p>The first one is this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadBaseControl</span> <span class="dt">IO</span> <span class="dt">RemoteM</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">StM</span> <span class="dt">RemoteM</span> a <span class="ot">=</span> <span class="dt">StM</span> (<span class="dt">StateT</span> <span class="dt">Ctx</span> <span class="dt">Process</span>) a</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  liftBaseWith f <span class="ot">=</span> <span class="dt">RemotePure</span> <span class="op">$</span> liftBaseWith <span class="op">$</span> \q <span class="ot">-&gt;</span> f (q <span class="op">.</span> runRemote)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  restoreM <span class="ot">=</span> <span class="dt">RemotePure</span> <span class="op">.</span> restoreM</span></code></pre></div>
<p>Why this works? Also, it might not be immediately clear why <code>StM</code> appears on the right hand side. You might ask yourself “Did he just pull out the type StM out of thin air and reused it?”. It’s allright, I have been there myself. Haskell notation is so dense sometimes it’s easy to get lost. The key insigth is this: <strong>StM is NOT a type, is a type-level FUNCTION!</strong> Here, all we are doing is calling <code>StM</code> on the RHS, effectively offloading computing the result and hoping that somebody already defined in the stack the final solution. So we are effectively applying <code>StM</code> to <code>(StateT Ctx Process) a</code> as an argument. And this is exactly <em>why</em> GHC asks us to enable <code>UndecidableInstances</code>. It cannot guarantee, without compiling the program, that GHC will terminate. Effectively (if I recall correctly what Andres Loh once told us in an Haskell course in London), as scary as the name might sound, <code>UndecidableInstances</code> simply tells us “hey, it’s probably going to be fine, but there is a chance the typechecking might not terminate”. This is (very loosely speaking) because the RHS doesn’t “reduce” as it has the same number of terms of the LHS, so GHC gets suspicious.</p>
<p>The other approach is to simply ask GHC for the result of the type family. How? Let’s fire up <code>ghci</code>, and let’s type this:</p>
<pre><code>ghci&gt; :set -XRankNTypes
ghci&gt; import Control.Monad.Trans.Control
ghci&gt; :kind! forall a. StM RemoteM a
forall a. StM RemoteM a :: *
= (a, Ctx)</code></pre>
<p>Wow, can you believe how easy it was? It’s equally easy to convince ourselves why this result makes sense: this is nothing more of the result of applying <code>Stm</code> to <code>StateT Ctx Process</code>. Let’s find out:</p>
<pre><code>ghci&gt; import Control.Monad.Trans.State.Strict
ghci&gt; import Control.Distributed.Process
ghci&gt; :kind! forall a. StM (StateT Ctx Process) a
forall a. StM (StateT Ctx Process) a :: *
= (a, Ctx)</code></pre>
<p>And the best part is that now we don’t need <code>UndecidableInstances</code>, and we are much more confident we are computing <code>StM</code> the right way. Our definition becomes:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadBaseControl</span> <span class="dt">IO</span> <span class="dt">RemoteM</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">StM</span> <span class="dt">RemoteM</span> a <span class="ot">=</span> (a, <span class="dt">Ctx</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  liftBaseWith f <span class="ot">=</span> <span class="dt">RemotePure</span> <span class="op">$</span> liftBaseWith <span class="op">$</span> \q <span class="ot">-&gt;</span> f (q <span class="op">.</span> runRemote)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  restoreM <span class="ot">=</span> <span class="dt">RemotePure</span> <span class="op">.</span> restoreM</span></code></pre></div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Thanks, Daniel Wagner!<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>iconv-typed: An experiment in API design and type safety</title>
    <link href="http://www.alfredodinapoli.com/posts/2016-10-23-iconv-typed-an-experiment-in-api-design-and-type-safety.html" />
    <id>http://www.alfredodinapoli.com/posts/2016-10-23-iconv-typed-an-experiment-in-api-design-and-type-safety.html</id>
    <published>2016-10-23T00:00:00Z</published>
    <updated>2016-10-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<pre><code>Summary: I&#39;m releasing a type safe version of the iconv library, discussing my
API design choices and asking for feedback from the community.</code></pre>
<hr/>
<p>I’m slowly making progress in an Haskell <a href="https://github.com/adinapoli/piece-table">piece table</a> library which could be used as a high performant data structure for text manipulation. The typical use case there would be writing a text editor in Haskell, something I had in the back of my mind doing (for fun) for a while.</p>
<p>So far the assumption I have made whilst developing it is that user text would be encoded/decoded as <code>UTF-8</code>, but in the real world, though, this is simply not true! That’s where <a href="http://kunststube.net/encoding/">encoding</a> comes into play. I won’t get into too much detail about the <code>piece table</code> library (is not that interesting in its current shape!), but this should set the scene on why I needed text encoding in the first place.</p>
<p>In Haskell we have a couple of choices when dealing with text encoding: we can use some <a href="http://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Encoding.html">functions</a> provided directly by the <code>text</code> library, use the <a href="http://hackage.haskell.org/package/encoding">encoding</a> library or use Duncan Coutt’s <a href="http://hackage.haskell.org/package/iconv-0.4.1.3/docs/Codec-Text-IConv.html">iconv</a> library. I really like <code>iconv</code> because it has such a simple API and it doesn’t assume anything on the input: the latter is given as a “blob of binary data” and it’s up to me to decide how to interpret it.</p>
<p>Despite its simplicity, I always thought the library also had great potential for things to go wrong: first of all, an <code>EncodingName</code> is simply a <code>String</code>, which the programmer can mispell and spend hours debugging why is program in producing garbage. Secondly, it requires the manual step of retrieving the list of available encodings from the system, typically piggybacking on the underlying C/GNU library. This is why today I’m releasing <a href="https://github.com/adinapoli/iconv-typed">iconv-typed</a> mainly to gather feedback from the community. It’s such a simply abstraction over <code>iconv</code> I’m surprised nobody thought about something similar, but maybe that’s because it’s so simple people have wrote it in their own projects without releasing it, or simply because maybe it has shortcomings I haven’t anticipated!</p>
<h2 id="a-taste-of-the-api">A taste of the API</h2>
<p>APIwise, the library should feel familiar with the original <code>iconv</code>. Compare this short example using the <code>iconv</code> library:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Codec.Text.IConv</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> convert <span class="st">&quot;UTF-8&quot;</span> <span class="st">&quot;LATIN1&quot;</span> <span class="st">&quot;hello&quot;</span></span></code></pre></div>
<p>With the equivalent in <code>iconv-typed</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Codec.Text.IConv.Typed</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> convert <span class="op">@</span><span class="st">&quot;UTF-8&quot;</span> <span class="op">@</span><span class="st">&quot;LATIN1&quot;</span> <span class="st">&quot;hello&quot;</span></span></code></pre></div>
<p>As you can see it’s almost identical except for the fact we are using <code>TypeApplication</code>’s <code>@</code> operator. If we mispelled by accident <code>UTF-8</code>, we would get a type error. Profit! But how does it work?</p>
<h2 id="type-families-to-the-rescue">Type families to the rescue!</h2>
<p>Conceptually, it’s very simple: it fetches all the available encodings in a platform-dependent way (mainly invoking <code>iconv -l</code> under the hood), and then generates a closed <a href="https://wiki.haskell.org/GHC/Type_families">type family</a> via <a href="https://wiki.haskell.org/Template_Haskell">template Haskell</a> to basically constrain the <code>Symbol</code> universe only to ones matching a valid encoding. A code snippet will demostrate this much better! We first commit the biggest sin in the whole Haskell universe and we get the encodings via <code>unsafePerformIO</code> [1] (it requires the <code>Shelly</code> library):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getAvailableEncodings ::</span> [<span class="dt">EncodingName</span>]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>getAvailableEncodings <span class="ot">=</span> unsafePerformIO <span class="op">$</span> shelly <span class="op">$</span> silently <span class="op">$</span> escaping <span class="dt">False</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> T.unpack <span class="op">.</span> <span class="fu">mconcat</span> <span class="op">.</span> <span class="fu">map</span> T.words <span class="op">.</span> T.lines <span class="op">.</span> T.strip <span class="op">&lt;$&gt;</span> run <span class="st">&quot;iconv&quot;</span> [<span class="st">&quot;-l&quot;</span>]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# NOINLINE getAvailableEncodings #-}</span></span></code></pre></div>
<p>… and then we generate the type family where each instance would look like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">ValidEncoding</span> (<span class="ot">k ::</span> <span class="dt">Symbol</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ValidEncoding</span> <span class="st">&quot;RETRIEVED_ENCODING_1&quot;</span> <span class="ot">=</span> <span class="dt">&#39;True</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ValidEncoding</span> <span class="st">&quot;RETRIEVED_ENCODING_2&quot;</span> <span class="ot">=</span> <span class="dt">&#39;True</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>Note two things: we are using a <em>closed</em> type family to avoid “monkey patching” of our encodings (something which could happen if we chose a typeclass as an abstraction mechanism, as someone could have defined an orphan instance) and we “plug” directly each retrieved encoding as a string literal. So far so good! The “magic” between the minimal API lies in this few lines of code:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Enc</span> k1 k2 <span class="ot">=</span> <span class="dt">ByteString</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="ot">convert ::</span> <span class="kw">forall</span> k1 k2<span class="op">.</span> ( <span class="dt">KnownSymbol</span> k1</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>            , <span class="dt">KnownSymbol</span> k2</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>            , <span class="dt">ValidEncoding</span> k1 <span class="op">~</span> <span class="dt">&#39;True</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>            , <span class="dt">ValidEncoding</span> k2 <span class="op">~</span> <span class="dt">&#39;True</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>         <span class="ot">=&gt;</span> <span class="dt">Enc</span> (<span class="ot">k1 ::</span> <span class="dt">Symbol</span>) (<span class="ot">k2 ::</span> <span class="dt">Symbol</span>) <span class="co">-- ^ Input text</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="co">-- ^ Output text</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>convert input <span class="ot">=</span> I.convert (reifyEncoding (<span class="dt">E</span> <span class="op">@</span>k1)) (reifyEncoding (<span class="dt">E</span> <span class="op">@</span>k2)) input</span></code></pre></div>
<p>First of all, we define a type synonym called <code>Enc</code> with 2 phantom types, which will be “filled” by our encodings. This unfortunately generate ambiguity and GHC reports this at compile time. We can help the ambiguity resolving by using <code>AllowAmbiguousTypes</code>, which basically (check this <a href="https://www.reddit.com/r/haskell/comments/59g49o/iconvtyped_an_experiment_in_api_design_and_type/d99pnhx/">insigthful comment</a> on Reddit for the full explanation. Thanks <code>/u/int_index</code>!)</p>
<p>The <code>convert</code> function has a bit of an intimidating, so let’s start from the typeclass constraints: what I’m saying here is that for any genering <code>k1</code> and <code>k2</code> I want those to:</p>
<ul>
<li><p>Be an instance of <code>KnownSymbol</code> (think about a <code>String</code> at the type level) so I can reify them back at the value level with <code>reifyEncoding</code> (which is basically just <code>symbolVal</code> under the hood).</p></li>
<li><p>The type-level function <code>ValidEncoding</code> must yield <code>True</code>. Simply put, this will only be possibly with the <code>Symbol</code>s I have defined an instance for in my closed type family. This is what will prevent you from passing an input a non-existing or mispelled encoding.</p></li>
</ul>
<p>The input <code>ByteString</code> is well, just a <code>ByteString</code> in disguise. Remember <code>Enc</code>? That’s basically it, with the only twist of carrying these 2 extra types around, which I’m also saying they are of <em>type</em> <code>Symbol</code>, and this is where I need <code>TypeInType</code>, as <code>Symbol</code> would normally be a <code>Kind</code>.</p>
<p>This is the gist of it! But why am I able to invoke the <code>convert</code> function like this?</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> convert <span class="op">@</span><span class="st">&quot;UTF-8&quot;</span> <span class="op">@</span><span class="st">&quot;LATIN1&quot;</span> <span class="st">&quot;hello&quot;</span></span></code></pre></div>
<p>Here is <code>TypeApplications</code> in action! What we are doing is giving an hint to the compiler about which types are <code>k1</code> and <code>k2</code>, as the only <em>real</em> input is the input <code>Enc k1 k2</code>. Other way to see this, is that we are saying “Hey GHC, <code>Enc</code> carries the utterly generic &amp; ambiguous <code>k1</code> and <code>k2</code>, I’m telling you explicitly what those 2 are”.</p>
<p>That’s pretty much it, really!</p>
<h2 id="usability-the-unknown">Usability: the unknown</h2>
<p>Something I still have no clue is how practical to use this library will be, mostly because those encodings don’t exist at the value level. But not only that, is also very likely you have some existing code which is doing any kind of manipulation with the <code>EncodingName</code>, like comparing them, reading them from disk, from user input, etc. After all, they are only <code>String</code>s. I suspect doing the equivalent with this library will be clunky, although I hope <code>TypeInType</code> can help in this regard.</p>
<h2 id="you-said-api-design">You said API design?</h2>
<p>The current API is the result of multiple iterations. Initially I was going to use a much simpler approach and simply have my TH code generate plain types so that our API could look like:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>convert <span class="dt">UTF8</span> <span class="dt">LATIN1</span> <span class="st">&quot;hello&quot;</span></span></code></pre></div>
<p>This was jolly good for the simplest encodings, but I quickly run into limitations in the allowed characters to be used for a type/type constructor. For example, <code>-</code> is not allowed, so I could have the choice of mangling <code>UTF-8</code> into <code>UTF_8</code>, which would have been OK. But what about <code>ISO_646.IRV:1991</code>? I quickly realised this approach had 2 problems:</p>
<ul>
<li>It would require the user to “lookup” the mangled name of Haddock as I couldn’t come up with a mnemonic rule for translating encoding into types</li>
<li>Converting original <code>iconv</code> code would have been a bit painful.</li>
</ul>
<p>In my opinion, if you are releasing a library which is meant to simplify user life, you really want to aim for a low entry barrier!</p>
<h3 id="second-attempt-use-an-ancilliary-e-type">Second attempt: Use an ancilliary <code>E</code> type</h3>
<p>My second attempt is basically what I ended up releasing as the “GHC 7.x” API version. It does work, but when I first releases the library and I tweeted the link to GitHub, <a href="https://twitter.com/a_cowley/status/790236285847863296">Anthony Cowley</a> gave valuable suggestions on how to improve it, which made me realise that if I was going to use <code>TypeApplications</code> and therefore tap into GHC 8.x anyway, I had access to <code>TypeInType</code> also! That yielded a much nicer API.</p>
<h3 id="final-attempt-perfection">Final attempt: Perfection?</h3>
<p>Exploring the solution space brought me in a place where I feel I have come up with an API which strikes me as a good compromise. The only sour taste in my mouth is the use of <code>AllowAmbiguousTypes</code>, which I wasn’t able to avoid.</p>
<h2 id="support-for-ghc-7.x">Support for GHC 7.x</h2>
<p>Althought not as slick and elegant as the version which uses <code>TypeInType</code> and <code>TypeApplications</code>, we support older versions of GHC. This is how the API would look like if you try to compile <code>iconv-typed</code> with GHC 7.x:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Codec.Text.IConv.Typed</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> convert (<span class="dt">E</span><span class="ot"> ::</span> <span class="dt">E</span> <span class="st">&quot;UTF-8&quot;</span>) (<span class="dt">E</span><span class="ot"> ::</span> <span class="dt">E</span> <span class="st">&quot;LATIN1&quot;</span>) <span class="st">&quot;hello&quot;</span></span></code></pre></div>
<h2 id="unexplored-territory">Unexplored territory</h2>
<p>As a result of my encoding fetching at compile time, there is something which is subtle and with an impact I cannot anticipate: <strong>If you try to run a program which is using iconv-typed on a machine which doesn’t support a particular encoding, your application won’t compile</strong>.</p>
<p>Differently put, if you are doomed to produce garbage as part of your encoding process because your underlying iconv library doesn’t support that particular encoding, the library will prevent you from even trying. This could certainly be terrifying or beautiful, depending from the point of view.</p>
<p>I guess we will have to wait and see!</p>
<h2 id="notes">Notes</h2>
<p>[1] Using <code>unsafePerformIO</code> here is not necessary, using <code>runIO</code> in the <code>Q</code> monad would have worked as well, and avoid unsafe operations.</p>]]></summary>
</entry>
<entry>
    <title>Paginators are Mealy Machines in disguise</title>
    <link href="http://www.alfredodinapoli.com/posts/2016-09-10-paginators-are-mealy-machines-in-disguise.html" />
    <id>http://www.alfredodinapoli.com/posts/2016-09-10-paginators-are-mealy-machines-in-disguise.html</id>
    <published>2016-09-10T00:00:00Z</published>
    <updated>2016-09-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="paginators-are-mealy-machines-in-disguise">Paginators are Mealy Machines in disguise</h1>
<pre><code>Summary: At work I needed to stream some data out from a service which returned data in paginated chunks.
Using a very simple data type based on Mealy Machines worked surprisingly well.</code></pre>
<p>One of the aspect I enjoy most of programming is when you have the chance of applying something you have learned in the real world. A couple of weeks ago I needed to create a tool to “garbage collect” old <a href="https://aws.amazon.com/ecr/">ECR</a> images. Very simply put, <em>ECR</em> stands for <em>EC2 Container Registry</em> and is no more, no less, a private Docker Registry you can use as part of the impressive AWS (<em>Amazon Web Service</em>) toolkit.</p>
<p><em>ECR</em> works by having a set of <em>repositories</em>, and for each of them you can upload up to 500 Docker images. If you exceed this limit, you will have either to delete some images to create free space, or contact the Amazon customer service to dump the upper limit up. My team uses <code>ECR</code> to store the images associated to the Haskell micro services we deploy using <a href="https://aws.amazon.com/documentation/elastic-beanstalk/">Elastic Beanstalk</a>, and each time we do a deploy, we create and upload a new versioned image for each micro service, so it comes as no surprise that space in the repositories is going to finish sooner or later. So the problem is simple: “I have some images stored in the cloud and I need to delete them”.</p>
<p>Now, we could have used the quite impressive <a href="http://hackage.haskell.org/package/amazonka-ecr">amazonka-ecr</a> to solve our problem, but historically we have been using the <a href="https://aws.amazon.com/cli/">aws-cli</a> even before Amazonka was around, and sometimes is just super easy to slurp the output of a cli application and to decode that from JSON. Short story short, this is why we didn’t piggyback on this excellent third-party library, but that’s a bit of an OT. What’s important is that to solve our problem, we only need two commands from the <code>aws-cli</code>: <a href="http://docs.aws.amazon.com/cli/latest/reference/ecr/list-images.html">list-images</a> to retrieve all our images, and <a href="http://docs.aws.amazon.com/cli/latest/reference/ecr/batch-delete-image.html">batch-delete-image</a> to delete the ones which meet our criteria (in our case that would be deleting anything older than 2 months).</p>
<p><code>list-image</code> doesn’t return the whole set of images, as this would be a beefy JSON! What it does instead, is to return a JSON packet with a <code>Token</code> identifying if we have more data to fetch. This is a standard <code>pagination</code> technique: other strategies would be, for example, to return the current page and the total number of pages, so that the user can advance forward or backward. We can easily model an <code>ECRImage</code> as a simple data type by following the specification on the <code>list-image</code> page:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Useful import to use in the rest of the post</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Aeson</span> <span class="kw">as</span> <span class="dt">JSON</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Aeson.TH</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Functor.Identity</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">List</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.String.Conv</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Shelly</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ECRImage</span> <span class="ot">=</span> <span class="dt">ECRImage</span> {</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    imageDigest ::</span> <span class="dt">T.Text</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> imageTag    ::</span> <span class="dt">Maybe</span> <span class="dt">T.Text</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>deriveFromJSON defaultOptions { omitNothingFields <span class="ot">=</span> <span class="dt">True</span> } &#39;<span class="dt">&#39;ECRImage</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">NextToken</span> <span class="ot">=</span> <span class="dt">T.Text</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ECRListImages</span> <span class="ot">=</span> <span class="dt">ECRListImages</span> {</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="ot">    nextToken ::</span> <span class="dt">Maybe</span> <span class="dt">NextToken</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> imageIds  ::</span> [<span class="dt">ECRImage</span>]</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>deriveFromJSON defaultOptions { omitNothingFields <span class="ot">=</span> <span class="dt">True</span> } &#39;<span class="dt">&#39;ECRListImages</span></span></code></pre></div>
<p>The <code>ECRListImages</code> is an umbrella type we define to parse the raw JSON that AWS gives us, which will include the token <em>AND</em> the data fetched so far. When I approached this problem, I knew two things for sure:</p>
<ul>
<li>I didn’t want to fetch the whole dataset into memory, but rather processing it in chunks</li>
<li>The problem itself was screaming “streaming!”</li>
</ul>
<p>Although I could have simply written a recursive function which would fetch the current data and the token, process it, and recur in case we still had data to fetch, that stroke me as a poor solution. Not bacause it was <em>intrinsically</em> bad, but only because it felt a bit ad-hoc and didn’t compose very well. What if I wanted to step through the data “one chunk” at the time? What if I wanted to filter each chunk according to a predicate and retain only a subset of it? Sure, I could extend my function which a predicate to filter on, but that felt even more ad-hoc. So I took a step backward and wondered if I could come up with a super tiny abstraction to “step” through the data whilst retaining code reuse and composition. After some failing attempt, I came up with this small data structure, which I’m calling here <code>ForwardPaginator</code> to stress the fact we cannot iterate backward (yet), which is something I didn’t need to support anyway:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ForwardPaginator</span> m i o <span class="ot">=</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">PaginatorLeaf</span> o</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">PaginatorFetch</span> (<span class="dt">Maybe</span> i <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> i, o, <span class="dt">ForwardPaginator</span> m i o))</span></code></pre></div>
<p>A <code>ForwardPaginator</code> effectively models a tree of computations; we can have a <em>leaf</em>, meaning we have just started our machine and are at step zero, or a <em>fetch</em> step that, given an input <code>i</code> will produce a triple <code>(newInput, output, paginator)</code>, doing (or not) some monadic effect in the process (thus the <code>m</code> wrapping). Due to the fact we could have exhausted our input, we encapsulate this possibility in a <code>Maybe</code>, which explains the presence of those <code>Maybe i</code>. We can even define what seems to be a legal <code>Functor</code> instance for it:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">ForwardPaginator</span> m i) <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">PaginatorLeaf</span>  a) <span class="ot">=</span> <span class="dt">PaginatorLeaf</span> (f a)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">PaginatorFetch</span> g) <span class="ot">=</span> <span class="dt">PaginatorFetch</span> <span class="op">$</span> \nextToken <span class="ot">-&gt;</span> (\(x,y,z) <span class="ot">-&gt;</span> (x, f y, <span class="fu">fmap</span> f z)) <span class="op">&lt;$&gt;</span> g nextToken</span></code></pre></div>
<p>(Note to the reader: I have the intuition we should be able to define a <code>Contravariant</code> instance for our <code>ForwardPaginator</code>, but I’m not 100% sure as <code>i</code> appears both in positive and negative position. A <code>Profunctor</code> even? Please comment below or on Reddit if you think this is possible, I simply haven’t tried yet.)</p>
<p>If you squint hard, you will recognise that what we have in the <code>PaginatorFetch</code> step is essentially <code>Mealy</code> machine! This is not very surprising; <a href="http://neilmitchell.blogspot.it/2013/12/progress-reporting-in-shake.html">Neil Mitchell used it in Shake</a> only to discover his data structure was indeed a Mealy machine and his definition was almost verbatim to the one included in the <a href="http://hackage.haskell.org/package/machines-0.6.1/docs/Data-Machine-Mealy.html">machine package</a>. What I find cool is that both me and Neil went through the same creative process; we modeled our solution using an abstraction we later found out be something already present in literature! I find both depressing and invigorating to discover that your clever idea is something someone thought about a long time before you! Oh well, at least that gave me the confidence I was on the right track. Incidentally, <a href="https://ocharles.org.uk/blog/posts/2013-08-01-getting-started-with-netwire-and-sdl.html">Ollie blogged</a> in 2013 about FRP and Netwire, and guess what his <code>Auto</code> type looks like ;)</p>
<p>The reader might be thinking by now “Ok, but what can you do with this?” A Mealy machine is something very simple at its heart, and copying its definition from Wikipedia <em>“…is a finite-state machine whose output values are determined both by its current state and the current inputs.[…]”</em>. Simply put, we can use the current state and the current input(s) to decide where to go next (which could be advance the machine or stop altogether). To be completely honest with you, whilst writing this blog post, I was on the fence about considering what’s inside a <code>PaginatorFetch</code> a Mealy or a Moore machine, as it resemble a bit of both, but I <em>eventually settle on the former, as effectively it’s the input (the “token”) which determines if we can step further or not</em>.</p>
<p>Armed with our <code>ForwardPaginator</code>, let’s generalise it to our domain problem:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">NextToken</span> <span class="ot">=</span> <span class="dt">T.Text</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Repository</span> <span class="ot">=</span> <span class="dt">T.Text</span> <span class="co">-- Will use this later</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ECRPaginator</span> m a <span class="ot">=</span> <span class="dt">ForwardPaginator</span> m <span class="dt">NextToken</span> a</span></code></pre></div>
<p>Now, let’s get the elephant out of the room and let me give you the (rather) uninteresting definition of our ECR paginator. I personally think that the semantic of the data structure and the operations we can perform of it are much more interesting, but I wanted to post a “real world” paginator just to prove this stuff can also pay the bills ;)</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ecrListImagesPaginated ::</span> <span class="dt">Repository</span> <span class="ot">-&gt;</span> <span class="dt">ECRPaginator</span> <span class="dt">Sh</span> [<span class="dt">ECRImage</span>]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>ecrListImagesPaginated repo <span class="ot">=</span> <span class="dt">PaginatorFetch</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  initialState <span class="ot">&lt;-</span> run <span class="st">&quot;aws&quot;</span> cmd</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> JSON.eitherDecode (toS initialState) <span class="kw">of</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span> ex <span class="ot">-&gt;</span> yieldZero ex</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> (<span class="dt">ECRListImages</span> <span class="dt">Nothing</span> items) <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Nothing</span>, items, <span class="dt">PaginatorLeaf</span> <span class="fu">mempty</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> (<span class="dt">ECRListImages</span> mbToken items) <span class="ot">-&gt;</span> <span class="fu">return</span> (mbToken, items, fetch)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    yieldZero ex <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>      echo <span class="st">&quot;aws ecr list-images failed to decode to valid JSON. Error was: &quot;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>      echo (toS <span class="op">.</span> <span class="fu">show</span> <span class="op">$</span> ex)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> (<span class="dt">Nothing</span>, <span class="fu">mempty</span>, <span class="dt">PaginatorLeaf</span> <span class="fu">mempty</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    cmd <span class="ot">=</span> [ <span class="st">&quot;ecr&quot;</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>          , <span class="st">&quot;list-images&quot;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>          , <span class="st">&quot;--region&quot;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>          , <span class="st">&quot;eu-west-1&quot;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>          , <span class="st">&quot;--repository-name&quot;</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>          , repo</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>          ]</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="ot">    fetch ::</span> <span class="dt">ECRPaginator</span> <span class="dt">Sh</span> [<span class="dt">ECRImage</span>]</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    fetch <span class="ot">=</span> <span class="dt">PaginatorFetch</span> <span class="op">$</span> \token <span class="ot">-&gt;</span> <span class="kw">case</span> token <span class="kw">of</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Nothing</span>, <span class="fu">mempty</span>, <span class="dt">PaginatorLeaf</span> <span class="fu">mempty</span>)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Just</span> t  <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        rawJson <span class="ot">&lt;-</span> run <span class="st">&quot;aws&quot;</span> cmd</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> JSON.eitherDecode (toS rawJson) <span class="kw">of</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Left</span> ex <span class="ot">-&gt;</span> yieldZero ex</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Right</span> (<span class="dt">ECRListImages</span> mbToken items) <span class="ot">-&gt;</span> <span class="fu">return</span> (mbToken, items, fetch)</span></code></pre></div>
<p>The caveat here is that we need to repeat the call to <code>aws ecr</code> twice as we need to call it at least once to acquire a valid token, so that externally we will be able to pass <code>Nothing</code> to our paginator to start it. I have chosen <code>Sh</code> as my monad of choice (from the <a href="http://hackage.haskell.org/package/shelly">shelly</a> package), so that I can run <code>bash</code> commands easily.</p>
<p>Now the fun begins! What we can do with this paginator and more generally with a <code>ForwardPaginator</code>?</p>
<p>The first operation we can think of is effectively “stepping” the paginator, and implementing this function is not very hard:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">next ::</span> <span class="dt">Monad</span> m</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>     <span class="ot">=&gt;</span> <span class="dt">ForwardPaginator</span> m i a</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>     <span class="ot">-&gt;</span> <span class="dt">Maybe</span> i</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- ^ The initial input state to use.</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>     <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> i, a, <span class="dt">ForwardPaginator</span> m i a)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>next (<span class="dt">PaginatorLeaf</span> i) _ <span class="ot">=</span> <span class="fu">return</span> (<span class="dt">Nothing</span>, i, <span class="dt">PaginatorLeaf</span> i)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>next (<span class="dt">PaginatorFetch</span> cont) tkn <span class="ot">=</span> cont tkn</span></code></pre></div>
<p>Note how this function is completely generic in terms of <code>m</code>, <code>i</code> and <code>a</code>, apart from the <code>Monad</code> constraint, which means I can “step” arbitrary paginators – talk about code reuse! Another thing we might want is to be evil and fold all the data returned from the paginator into a giant collection. Not hard as well:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foldPaginator ::</span> (<span class="dt">Monad</span> m, <span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> <span class="dt">ForwardPaginator</span> m i a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> i <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>foldPaginator (<span class="dt">PaginatorLeaf</span> items) _ acc <span class="ot">=</span> <span class="fu">return</span> (items <span class="ot">`mappend`</span> acc)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>foldPaginator (<span class="dt">PaginatorFetch</span> cont) tkn acc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  (t&#39;, acc&#39;, res) <span class="ot">&lt;-</span> cont tkn</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> res <span class="kw">of</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    leaf<span class="op">@</span>(<span class="dt">PaginatorLeaf</span> _) <span class="ot">-&gt;</span> foldPaginator leaf <span class="dt">Nothing</span> acc</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    nextFetch              <span class="ot">-&gt;</span> foldPaginator nextFetch t&#39; acc&#39;</span></code></pre></div>
<p>Again, the only constrain is that our accumulator must be a <code>Monoid</code>, so that we can effectively concatenate all the results together. This would also effectively allow us to return <em>all</em> the <code>ECRImage</code>(s) at once, but beware that this would load them into memory – not recommended for your production services!</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ecrListImages ::</span> <span class="dt">Repository</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">ECRImage</span>]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>ecrListImages repo <span class="ot">=</span> shelly <span class="op">$</span> foldPaginator (ecrListImagesPaginated repo) <span class="dt">Nothing</span> <span class="fu">mempty</span></span></code></pre></div>
<p>Something nice we can do with a <code>ForwardPaginator</code> is being able to find a particular element matching a predicate, short-circuiting our paginator as soon as we find a match, in order to avoid work and more generally expensive calls to external services:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">findPaginator ::</span> <span class="dt">Monad</span> m</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>              <span class="ot">=&gt;</span> <span class="dt">ForwardPaginator</span> m i [a]</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>              <span class="ot">-&gt;</span> <span class="dt">Maybe</span> i</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>              <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>              <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> a)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>findPaginator (<span class="dt">PaginatorLeaf</span> v) _ prd <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> List.find prd v</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>findPaginator (<span class="dt">PaginatorFetch</span> cont) tkn prd <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  (t&#39;,items,cont&#39;) <span class="ot">&lt;-</span> cont tkn</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> List.find prd items <span class="kw">of</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> i  <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> <span class="dt">Just</span> i</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> findPaginator cont&#39; t&#39; prd</span></code></pre></div>
<h2 id="pure-or-impure-pick-your-monad">Pure or impure? Pick your monad!</h2>
<p>To wrap up this blog post, I also wanted to show you how we are not bounded to use a “impure” monad for our <code>ForwardPaginator</code>: we could use something like <code>Identity</code>, <code>State</code>, <code>Reader</code> and so on and so forth. As an example, we will create a <code>ForwardPaginator</code> which can be built out of a pure function (full disclosure: <code>fib</code>, the classic, hehe) and everything will be pure to please the Haskell gods. Let’s start by defining both our pure function and the associated paginator:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>fib n <span class="ot">=</span> fib (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fib (n <span class="op">-</span> <span class="dv">2</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="ot">fibPaginator ::</span> <span class="dt">ForwardPaginator</span> <span class="dt">Identity</span> <span class="dt">Int</span> <span class="dt">Integer</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>fibPaginator <span class="ot">=</span> <span class="dt">PaginatorFetch</span> <span class="op">$</span> \continue <span class="ot">-&gt;</span> <span class="kw">case</span> continue <span class="kw">of</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Just</span> <span class="dv">1</span>, fib <span class="dv">0</span>, fibPaginator)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> i  <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Just</span> <span class="op">$</span> i <span class="op">+</span> <span class="dv">1</span>, fib i, fibPaginator)</span></code></pre></div>
<p>The slight twist is that in case we have no initial input, we return the base case of the recursion, otherwise we iterate in an infinite fashion, exactly like the original <code>fib</code> function. Now we can easily step the paginator using <code>next</code> to get one result at time, or create a convenient <code>take</code> function to get values out our infinite stream:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">takePaginator ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">ForwardPaginator</span> m i a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> i <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m [a]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>takePaginator (<span class="dt">PaginatorLeaf</span> v) _ _ <span class="ot">=</span> <span class="fu">return</span> [v]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>takePaginator (<span class="dt">PaginatorFetch</span> cont) tkn n</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> n <span class="op">&lt;=</span> <span class="dv">0</span> <span class="ot">=</span> <span class="fu">return</span> []</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    (newToken, o, newPaginator) <span class="ot">&lt;-</span> cont tkn</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    (o <span class="op">:</span>) <span class="op">&lt;$&gt;</span> takePaginator newPaginator newToken (n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>Using it is simple enough:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> runIdentity <span class="op">$</span> takePaginator fibPaginator <span class="dt">Nothing</span> <span class="dv">10</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">8</span>,<span class="dv">13</span>,<span class="dv">21</span>,<span class="dv">34</span>]</span></code></pre></div>
<p>As a bonus, as <code>ForwardPaginator</code> is a functor, we can easily map a function on the output values as we stream them:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> runIdentity <span class="op">$</span> takePaginator ((<span class="op">*</span><span class="dv">2</span>) <span class="op">&lt;$&gt;</span> fibPaginator) <span class="dt">Nothing</span> <span class="dv">10</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">10</span>,<span class="dv">16</span>,<span class="dv">26</span>,<span class="dv">42</span>,<span class="dv">68</span>]</span></code></pre></div>
<h2 id="stepping-backwards">Stepping backwards</h2>
<p>A bit of a pet peeve the reader migth have with this paginator is that is lacks the ability to step backward, and that would certainly be a valid concern. I still think though that adding the ability to iterate backward should be possible provided that we create a function <code>back</code> which bound the paginator monad to be a <code>MonadState (Maybe i)</code>, so that we can store the previous token and go backward and forward as we please. Something like this, for example:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prev ::</span> <span class="dt">MonadState</span> (<span class="dt">Maybe</span> i) m</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>     <span class="ot">=&gt;</span> <span class="dt">ForwardPaginator</span> m i a</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>     <span class="ot">-&gt;</span> <span class="dt">Maybe</span> i</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- ^ The initial input state to use.</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>     <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> i, <span class="dt">Maybe</span> a, <span class="dt">ForwardPaginator</span> m i a)</span></code></pre></div>
<p>I think we need to yield a <code>Maybe a</code> as output in case we want to step backward but we are already at the first “page”: in that case, we should yield no result. Maybe, if the readers are interested, I could explore this possibility in a subsequent blog post, which should effectively give us a <code>Paginator</code> worth its name, to be used in each scenario which requires bidirectional pagination.</p>
<h2 id="conclusions">Conclusions</h2>
<p>The ideas presented here are very simple but at the same time quite effective; They allowed me to solve my original problem in a nice compact way. Using <code>findPaginator</code> and the <code>Functor</code> instance I was able to first stop as soon as the current result set contained values I was interested in, and I was able to “zoom” only on pieces of the <code>ECRImage</code> data structure to extract things like the <code>ImageDigest</code>. So, next time you need to implement some form of pagination, remember you have the arsenal of Mealy and Moore Machines at your disposal: it’s not surprising they are called <em>stream transducers</em>!</p>]]></summary>
</entry>
<entry>
    <title>How I deploy Haskell Code</title>
    <link href="http://www.alfredodinapoli.com/posts/2015-11-03-how-i-deploy-haskell-code.html" />
    <id>http://www.alfredodinapoli.com/posts/2015-11-03-how-i-deploy-haskell-code.html</id>
    <published>2015-11-03T00:00:00Z</published>
    <updated>2015-11-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="how-i-deploy-haskell-code">How I deploy Haskell Code</h1>
<pre><code>Summary: I have recently switched to build my apps using an intermediate
Docker container and then simply drop the executable on the target machine.
This has worked remarkably well.</code></pre>
<p>Deploying Haskell code seems to be a pretty hot topic nowadays. Chatting with people at the Haskell Exchange last October made clear everyone has his own approach to put Haskell code into production. At work an approach I used and worked decently was to use <a href="http://www.ansible.com">Ansible</a> to build my project to an EC2 <code>development</code> machine, then dump an AMI (Amazon Machine Image) and reuse it across different environments. This had the advantage of making provisioning and rollback easy (at the end of the day you only need deploy a new AMI via the AWS’ EC2 API), but has the big snag of being quite slow if your development machine is a <code>tiny</code> instance or similar (which is typically the case for such kind of environments), as you need to perform a <code>cabal/stack</code> install remotely on the server.</p>
<p>Since switching to <a href="https://github.com/commercialhaskell/stack">stack</a> as my project builder/manager I have adopted a different approach which uses a mixture of old and new Unix tools and - although quite simple - it’s effective. It’s important to notice that this might not work for you if you want a technique which works on <strong>ALL</strong> the different Linux distros; this technique exploits FPComplete’s <code>stack-build</code> Docker image, which is based, to the best of my knowledge, on Ubuntu/Debian. Said that, I have been able to produce executables which worked on CentOS7 out of the box.</p>
<p>I should also add that the following techniques might be completely moot on Linux environments, where you <strong>should</strong> be using stack’s builtin <code>docker</code> feature to build your binaries. But being on Mac OS X, and considering the quirks of <code>boot2docker</code>, I was forced to find another solution. This is what I do these days:</p>
<ul>
<li><p>I use a <code>Dockerfile</code> for the build phase, called <code>Build.plan</code></p></li>
<li><p>I use <code>Build.plan</code> to provision a <code>stack-linux</code> executable which will act as my local <code>stack</code> but will target the Linux environment</p></li>
<li><p>I use <code>stack-linux</code> to install my project, mounting my local <code>$HOME/.stack</code> and <code>$PWD/.stack-work</code> in the container in order to cache builds and produce valid Unix executables.</p></li>
<li><p>I use <code>upx</code> to compress the output executables to the bare minimum</p></li>
<li><p>I upload the binaries &amp; the files listed in the <code>data-files</code> section of my <code>cabal</code> manifest on S3 in a folder called <code>myproject:version</code> (you can use any persistent key-value store)</p></li>
<li><p>I use <code>aws s3 sync</code> (you can use <code>rsync</code> if not targeting the AWS platform) to update my development machine with the newly provided binaries &amp; config files</p></li>
<li><p>I crack on with the rest of the deployment (<strong>NOTE</strong>: I still need to dump an AMI as the image needs to be used in a cluster, so YMMV)</p></li>
</ul>
<p>Let’s break down the points in more detail.</p>
<h3 id="create-stack-linux">Create stack-linux</h3>
<p>The <code>Build.plan</code> looks like this:</p>
<pre><code>FROM fpco/stack-build:lts-3.10

ADD .  /var/www/myproject
WORKDIR /var/www/myproject

CMD [&quot;stack&quot;]</code></pre>
<p>I usually tend to invoke <code>docker</code> to tag this image to be my “builder”, like so:</p>
<pre><code>docker build -t myproject-builder -f Build.plan .</code></pre>
<p>Now “creating” <code>stack-linux</code> is as easy as writing the following bash script:</p>
<pre><code>#!/usr/bin/env bash

# You might not need the following.
$({ boot2docker shellinit; } 2&gt;/dev/null)

docker run --rm \
       -v $HOME/path/to/my/project/myproject-dist:/root/.local \
       -v $HOME/path/to/my/project/.stack-work:/var/www/myproject/.stack-work \
       -v $HOME/.stack:/root/.stack \
       myproject-builder:latest stack $@</code></pre>
<p>The advantage here is that we are still writing in the host filesystem, but <code>stack</code> correctly installs the libraries in a separate folder:</p>
<pre><code>➜  ~  ls /Users/adinapoli/work/myproject/.stack-work/install
x86_64-linux    x86_64-osx</code></pre>
<h3 id="buildinginstalling-the-project">Building/installing the project</h3>
<p>At this point we are ready to call:</p>
<pre><code>stack-linux install</code></pre>
<p>And let it run for a while, depending on how many dependencies your projects has. At the end, you should have some linux binaries in the <code>myproject-dist</code> folder (have a look at the bash script we created for <code>stack-linux</code>). The good news is that future builds will read from your local <code>.stack-work</code> and will be much faster.</p>
<h3 id="compressing-with-upx">Compressing with UPX</h3>
<p>If all went well we should have a bunch of linux binaries in your <code>myproject-dist</code> which are already usable on their own. I decided to go a step further (I work remotely and I live in an area with sub-par internet connection) and compress the executables, to minimise the upload time towards S3. <code>upx</code> is a great tool that “just works”: Use it on your linux binaries and watch the size shrink down! For my work project, which is a medium Haskell app composed of roughly 13K lines of code I was able to get the final size down to <code>~9MB</code>. Not bad!</p>
<h3 id="uploading-binaries-data-files">Uploading binaries &amp; data files</h3>
<p>Finally we can tie the knot and upload on S3. I tend to use the <a href="http://hackage.haskell.org/package/shelly">shelly</a> library as my go-to tool for this kind of glue code:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">release ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>release vr <span class="ot">=</span> shelly <span class="op">$</span> escaping <span class="dt">False</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- If we are trying to release a version older than the current MyProject,</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- we need to checkout the relevant tag.</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  currentVersion <span class="ot">&lt;-</span> liftIO extractCabalVersion</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  when (currentVersion <span class="op">&gt;=</span> vr) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    echo <span class="st">&quot; * Older MyProject version required, checking out relevant git tag...&quot;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    run_ <span class="st">&quot;git&quot;</span> [<span class="st">&quot;checkout&quot;</span>, vr]</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> deployDir <span class="ot">=</span> <span class="st">&quot;/var/www/myproject&quot;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  run_ <span class="st">&quot;./build.sh&quot;</span> [] <span class="co">-- build.sh just calls docker build as I have showed you.</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Find project specific files and upload them as well.</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  (_, shareDir) <span class="ot">&lt;-</span> T.breakOn <span class="st">&quot;.&quot;</span> <span class="op">.</span> T.init <span class="op">&lt;$&gt;</span> run <span class="st">&quot;scripts/stack-linux&quot;</span> [<span class="st">&quot;path&quot;</span>, <span class="st">&quot;--local-install-root&quot;</span>]</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>  dataFiles <span class="ot">&lt;-</span> findDataFiles shareDir</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>  echo <span class="st">&quot; * Compressing executable(s)...&quot;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> myExes <span class="ot">=</span> [<span class="st">&quot;myexe1&quot;</span>, <span class="st">&quot;myexe2&quot;</span>] <span class="co">-- list here all the binaries you want to upload</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>  forM_ myExes <span class="op">$</span> \exe <span class="ot">-&gt;</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    run_ <span class="st">&quot;upx&quot;</span> [<span class="st">&quot;myproject-dist/bin/&quot;</span> <span class="op">&lt;&gt;</span> exe]</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>  echo <span class="st">&quot; * Transferring compressed files to S3...&quot;</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> releaseS3Prefix <span class="ot">=</span> <span class="st">&quot;s3://my-s3-bucket/&quot;</span> <span class="op">&lt;&gt;</span> vr</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>  run_ <span class="st">&quot;aws&quot;</span> [<span class="st">&quot;s3&quot;</span>, <span class="st">&quot;sync&quot;</span>, dataFiles, releaseS3Prefix <span class="op">&lt;&gt;</span> deployDir <span class="op">&lt;&gt;</span> <span class="st">&quot;/&quot;</span> <span class="op">&lt;&gt;</span> dataFiles]</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>  forM_ myExes <span class="op">$</span> \exe <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    run_ <span class="st">&quot;aws&quot;</span> [<span class="st">&quot;s3&quot;</span>, <span class="st">&quot;cp&quot;</span>, <span class="st">&quot;myproject-dist/bin/&quot;</span> <span class="op">&lt;&gt;</span> exe, releaseS3Prefix <span class="op">&lt;&gt;</span> <span class="st">&quot;/usr/bin/&quot;</span>]</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>  echo <span class="st">&quot; * Done!&quot;</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    findDataFiles shareDir <span class="ot">=</span> T.init <span class="op">&lt;$&gt;</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>      run <span class="st">&quot;ls&quot;</span> [<span class="st">&quot;-d&quot;</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>               , shareDir <span class="op">&lt;&gt;</span> <span class="st">&quot;share/*/*&quot;</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>               , <span class="st">&quot;|&quot;</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>               , <span class="st">&quot;grep&quot;</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>               , <span class="st">&quot;myproject-&quot;</span> <span class="op">&lt;&gt;</span> vr]</span></code></pre></div>
<p>We essentially did the steps I already explained, with this twist:</p>
<ul>
<li>We searched within <code>.stack-work</code> to find any file listed in the <code>data-files</code> section of the cabal manifest and we copied them over on S3. This is because, in my specific case, I had configuration files my exe needed to run. Again, YMMV!</li>
</ul>
<p>At this point your binaries (and config files) are on S3, properly versioned (I have used my project version here). Now rolling back it’s just a matter of transferring a couple of files over!</p>
<p>For completeness, this is an excerpt of a section of my Ansible scripts, which copies the files as we discussed:</p>
<pre><code>- name: Install MyProject
  remote_user: service-runner
  sudo: no
  shell: aws s3 sync s3://my-s3-bucket/{{myproject_version}}/usr/bin/ /usr/local/bin/ &amp;&amp;
         aws s3 sync s3://my-s3-bucket/{{myproject_version}}/var/www/myproject/ /var/www/project/</code></pre>
<p>Easy!</p>
<h3 id="caveats-and-elephants-in-the-room">Caveats and Elephants in the room</h3>
<ul>
<li><p>As said, this technique is by no means universal; chances are it might not suit you for various reasons.</p></li>
<li><p>It doesn’t aim to provide static executables; as you know <a href="https://ro-che.info/articles/2015-10-26-static-linking-ghc">this is possible</a> (and not difficult at all) up to a point.</p></li>
<li><p>You <em>might</em> (memory here does not help me) need to install whichever C library your executable depends upon. For example at least one of my projects depends from <code>libpq</code>, so I had to <code>yum install</code> that on my target machine. You don’t need to worry about that when building though, thanks to the fact that <code>stack-build</code> provides you with all you need out of the box (did I mention how great is this?)</p></li>
</ul>
<h3 id="conclusions">Conclusions</h3>
<p>In this ocean full of DSLs, orchestrators and whatnot, I find this method simple and with these benefits:</p>
<ul>
<li>Easy versioning &amp; rollbacks</li>
<li>Small executables (You could potentially store them as binary blobs on a K-V store like Redis)</li>
<li>Native binaries, which entails:
<ul>
<li>No container overhead (even if minimal)</li>
<li>Stability (on CentOS7 my experience with Docker was not the best, but this is for another post)</li>
<li>No need for a private registry</li>
</ul></li>
<li>Cached builds (I pay the compilation time only on what’s really changed)</li>
</ul>]]></summary>
</entry>
<entry>
    <title>Announcing (and releasing) the rncryptor-hs library</title>
    <link href="http://www.alfredodinapoli.com/posts/2014-12-12-annoucing-the-rncryptor-hs-library.html" />
    <id>http://www.alfredodinapoli.com/posts/2014-12-12-annoucing-the-rncryptor-hs-library.html</id>
    <published>2014-12-12T00:00:00Z</published>
    <updated>2014-12-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="announcing-and-releasing-the-rncryptor-hs-library">Announcing (and releasing) the rncryptor-hs library</h2>
<p>Today I’m releasing the very supercalifragilistic first version of the <a href="https://github.com/adinapoli/rncryptor-hs">rncryptor-hs</a> library. This library is a reasonably fast implementation of the <a href="https://github.com/RNCryptor">RNCryptor</a> encrypted file format by <a href="http://robnapier.net/">Rob Napier</a>. It comes in two flavour:</p>
<ol type="1">
<li>A “oneshot” function which will decrypt the input bytes retaining all the content in memory</li>
<li>A streaming interface (using <a href="http://hackage.haskell.org/package/io-streams">io-streams</a>) for efficient decryption</li>
</ol>
<p>The state of the library is largely <strong>incomplete</strong>, as was hacked in the previous two days and a half to respond to a real world case scenario I had at work. Currently what’s implemented is only the decryption, there are basically no unit tests (or QuickCheck properties), but the quickest way for a library to grow is with people contributing to it, this is why I’m announcing it at a so-early stage.</p>
<h2 id="why-should-i-care">Why should I care?</h2>
<p>This library seems to be very widespread in the mobile world (especially on the ObjC side of it), thus if you are developing for iOS and need to encrypt stuff, there is a high chance you gonna stumble upon it. But when it comes to the server side of things, if you are using Haskell on your backend, you (were) out of luck. You could either use C++ and expose a C API and call it from your Haskell code, or use something like Python. There is actually a <a href="https://github.com/RNCryptor/RNCryptor-python">Python implementation</a>, but it reads the entire content to decrypt in memory, a luxury I could’t afford!</p>
<p>At work, we record, transcode and upload on S3 lots of videos, which are our most important resource. In doing so, we want to protect such media when we transfer them over the network, namely from our in-house iOS application towards Amazon’s S3. We then notify our transcoder server (written in Haskell) to go and fetch this encrypted video, decrypt it and upload it into another folder for the real transcoding to begin. So what I needed was a very simple streaming CLI program to take encrypted bytes from stdin, decrypt them, and send them over to stdout. Using my library this is actually quite a piece of cake:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Crypto.RNCryptor.V3</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.IO.Streams</span> <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Environment</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">B</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  args <span class="ot">&lt;-</span> getArgs</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> args <span class="kw">of</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        key<span class="op">:</span>_ <span class="ot">-&gt;</span> decryptStream (B.pack key) S.stdin S.stdout</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            _ <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;usage: decrypter &lt;key&gt;&quot;</span></span></code></pre></div>
<p>The flexibility <code>io-streams</code> give us means you are not limited to stdin/stdout, as you can build <code>InputStream</code> and <code>OutputStream</code> also from file <code>Handle</code>, raw <code>ByteString</code> and much more.</p>
<p>Combined with Amazon’s <a href="https://github.com/aws/aws-cli">aws-cli</a> tools, which provides streaming copy from and to S3, I can now download a file from S3, decrypt it and send it back in one pass, efficiently:</p>
<pre><code>aws s3 cp s3://my-bucket/stream - | decrypter mysecretkey | aws s3 cp - s3://my-bucket/new-stream</code></pre>
<p>Easy!</p>
<h2 id="whats-left-to-do">What’s left to do</h2>
<p>A lot of things actually! On top of my minds:</p>
<ul>
<li>HMAC validation</li>
<li>Testing!</li>
<li>Encryption</li>
<li>Make it independent from any streaming libraries, so that you can plug your own (conduit, pipes, you name it)</li>
</ul>
<p>PR are highly encouraged! XMas is coming, so is your spare time, please consider improving the Haskell library ecosystem ;)</p>
<p>The library is available on <a href="http://hackage.haskell.org/package/rncryptor">Hackage</a>, grab it while it’s hot!</p>
<h1 id="acknowledgements">Acknowledgements</h1>
<p>A big thank you to Rob Napier for kindly replying to my email with lots of useful insights which allowed me to fix a bug in my decryption routine.</p>
<p>Alfredo</p>]]></summary>
</entry>
<entry>
    <title>Copy Your Project Resources at Configure Time</title>
    <link href="http://www.alfredodinapoli.com/posts/2013-08-17-copy-your-project-resources-at-configure-time.html" />
    <id>http://www.alfredodinapoli.com/posts/2013-08-17-copy-your-project-resources-at-configure-time.html</id>
    <published>2013-08-17T00:00:00Z</published>
    <updated>2013-08-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This is mainly a note to myself, but I think it’s content it’s worthwhile to deserve a blog entry, and might save some headache to some other Haskeller as well.</p>
<h2 id="the-problem">The problem</h2>
<p>While rewriting my freelance project <a href="http://www.expiweb.it">Expiweb</a> in Haskell, I stumbled upon the following problem: my newly-created project uses <code>persistent</code>, which relies on TH. In one of my modules I have a snippet like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>share [mkPersist sqlSettings, mkMigrate <span class="st">&quot;migrateAuth&quot;</span>]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">$</span>(persistFileWith lowerCaseSettings (getSchemaFor <span class="st">&quot;auth&quot;</span>))</span></code></pre></div>
<p>Where <code>getSchema</code> is defined as such:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getSchemaFor ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">FilePath</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>getSchemaFor appName <span class="ot">=</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> p <span class="ot">=</span> unsafePerformIO getDataDir</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> p <span class="op">++</span> <span class="st">&quot;/resources/db/&quot;</span> <span class="op">++</span> appName <span class="op">++</span> <span class="st">&quot;/schema.txt&quot;</span></span></code></pre></div>
<p>This boils down to have the generated code to search, at <em>compile time</em>, for a file called <code>schema.txt</code> inside a <code>resources</code> directory. The accurate reader may notice I’m using <code>getDataDir</code>, to leverage the full power of Cabal. The problem with this code is that we have a mismatch between the nature of our code:</p>
<ul>
<li>The TH snippet generates and check code at <em>compile time</em></li>
<li><code>getDataDir</code> is meant to be used at <em>run time</em></li>
</ul>
<p>The proof is that the aforementioned function is generated inside a file called <code>Paths_yourprojectname.hs</code>, where <code>yourprojectname</code> is the name of your Cabal project. So, in my case, Cabal creates, <em>at compile time, but during the build step</em>, a module called <code>Paths_expiweb.hs</code>. So far so good, but now if we try to compile our project, we end up with an error message like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>src<span class="op">/</span><span class="dt">Expiweb</span><span class="op">/</span><span class="dt">Auth</span><span class="op">/</span>Types.hs<span class="op">:</span><span class="dv">27</span><span class="op">:</span><span class="dv">5</span><span class="op">:</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Exception</span> when trying to run compile<span class="op">-</span>time code<span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">/</span><span class="dt">Users</span><span class="op">/</span>adinapoli<span class="op">/</span>programming<span class="op">/</span>haskell<span class="op">/</span>expiweb<span class="op">.</span>hs<span class="op">/.</span>hsenv</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">/</span>cabal<span class="op">/</span>share<span class="op">/</span>expiweb<span class="op">-</span><span class="fl">0.0</span><span class="op">.</span><span class="fl">0.1</span><span class="op">/</span>resources<span class="op">/</span>db<span class="op">/</span>auth<span class="op">/</span>schema<span class="op">.</span>txt<span class="op">:</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    openFile<span class="op">:</span> does <span class="fu">not</span> exist (<span class="dt">No</span> su ch file <span class="fu">or</span> directory)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Code</span><span class="op">:</span> persistFileWith lowerCaseSettings (getSchemaFor <span class="st">&quot;auth&quot;</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">In</span> the second argument <span class="kw">of</span> <span class="ot">`share&#39;, namely</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="ot">      `</span><span class="op">$</span>(persistFileWith lowerCaseSettings (getSchemaFor <span class="st">&quot;auth&quot;</span>))&#39;</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">In</span> the expression<span class="op">:</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>      share</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        [mkPersist sqlSettings, mkMigrate <span class="st">&quot;migrateAuth&quot;</span>]</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        (<span class="op">$</span>(persistFileWith lowerCaseSettings (getSchemaFor <span class="st">&quot;auth&quot;</span>)))</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="dt">Failed</span> to install expiweb<span class="op">-</span><span class="fl">0.0</span><span class="op">.</span><span class="fl">0.1</span></span></code></pre></div>
<p>This, unsurprisingly, means that we need our <code>schema.txt</code> to be there at compile time.</p>
<h2 id="a-first-attempt-using-data-files-andor-extra-source-files">A first attempt: Using data-files and/or extra-source-files</h2>
<p>After googling a bit, the first thing I’ve tried to do was to use <code>data-files</code> to instruct Cabal about the fact I have files I want to be copied over when I install the package. The problem is that <code>data-files</code> works at <em>run time</em>! In other terms, our package will still be broken. This way is a dead end.</p>
<h2 id="a-second-attempt-using-paths_expiweb-inside-setup.hs">A second attempt: Using Paths_expiweb inside Setup.hs</h2>
<p>The second idea I had was to exploit the generated module <code>Paths_expiweb</code> inside a <code>Setup.hs</code> file, writing a <code>pre-build</code> hook to copy all the files I need using the aforementioned <code>getDataDir</code> function. The code might look like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#!/usr/bin/env runhaskell</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.Simple</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.PackageDescription</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.Package</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.Simple</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.Simple.LocalBuildInfo</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.Simple.Setup</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.Verbosity</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.Simple.Utils</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Paths_expiweb</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> defaultMainWithHooks myHooks</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> myHooks <span class="ot">=</span> simpleUserHooks { preBuild <span class="ot">=</span> copyResources }</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="ot">copyResources ::</span> <span class="dt">Args</span> </span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>              <span class="ot">-&gt;</span> <span class="dt">BuildFlags</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>              <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">HookedBuildInfo</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>copyResources args flags <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>  installDir <span class="ot">&lt;-</span> getDataDir</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  installDirectoryContents verbose <span class="st">&quot;resources&quot;</span> (installDir <span class="op">++</span> <span class="st">&quot;/resources&quot;</span>)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> emptyHookedBuildInfo</span></code></pre></div>
<p>This code seems to work, until you try to install the project inside a prestine environment (e.g. your production server): the problem is a classical <em>circular dependency</em> one: <code>Paths_expiweb</code> is created at <em>build time</em>, but we need to use it in our <code>Setup.hs</code> <em>before</em> it was even created (the proof is that, well, we need to import it, and <code>Setup.hs</code> needs to typecheck and compile before we can do anything)! So what?</p>
<h2 id="my-final-solution">My final solution</h2>
<p>The final solution is something similar, which I created shamelessly copying a script I’ve found in the <a href="http://comments.gmane.org/gmane.comp.lang.haskell.cafe/106000">Haskell Cafè</a>. <strong>Disclaimer: This will work only if you are using hsenv, but it’s simple to adapt to other scenarios</strong>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#!/usr/bin/env runhaskell</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.Simple</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.PackageDescription</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.Package</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.Simple</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.Simple.LocalBuildInfo</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.Simple.Setup</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.Verbosity</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.Simple.Utils</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Distribution.PackageDescription.Parse</span> (readPackageDescription)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Version</span> (showVersion)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Environment</span> (lookupEnv)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Expiweb package version, obtained parsing the cabal manifest file.</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="ot">pkgVersion&#39; ::</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>pkgVersion&#39; <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> (showVersion <span class="op">.</span> pkgVersion <span class="op">.</span> package <span class="op">.</span> packageDescription)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">$</span> readPackageDescription silent <span class="st">&quot;expiweb.cabal&quot;</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="co">-------------------------------------------------------------------------------</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="co">-- | My version of getDataDir, to use at configure time.</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="ot">getDataDir&#39; ::</span> <span class="dt">IO</span> <span class="dt">FilePath</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>getDataDir&#39; <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    hsenvPath <span class="ot">&lt;-</span> lookupEnv <span class="st">&quot;HSENV&quot;</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> hsenvPath <span class="kw">of</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;You need hsenv installed to install expiweb.&quot;</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Just</span> hPath) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>          version <span class="ot">&lt;-</span> pkgVersion&#39;</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>          <span class="fu">return</span> <span class="op">$</span> hPath <span class="op">++</span> <span class="st">&quot;/.hsenv/cabal/share/expiweb-&quot;</span> <span class="op">++</span> version</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> defaultMainWithHooks expiwebHooks</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> expiwebHooks <span class="ot">=</span> simpleUserHooks { preBuild <span class="ot">=</span> copyExpiwebResources }</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a><span class="ot">copyExpiwebResources ::</span> <span class="dt">Args</span> </span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>                     <span class="ot">-&gt;</span> <span class="dt">BuildFlags</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>                     <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">HookedBuildInfo</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>copyExpiwebResources args flags <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>  installDir <span class="ot">&lt;-</span> getDataDir&#39;</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>  installDirectoryContents verbose <span class="st">&quot;resources&quot;</span> (installDir <span class="op">++</span> <span class="st">&quot;/resources&quot;</span>)</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> emptyHookedBuildInfo</span></code></pre></div>
<p>The trick is simple: We know that, under <code>hsenv</code>, <code>cabal</code> will install package resources under <code>/cabal/share/packagename-packageversion</code>, so all we need is:</p>
<ul>
<li><p>Get the absolute path of our <code>hsenv</code> environment, looking up its variable in the environment</p></li>
<li><p>Get the current package version, to allow the script to work across different versions. This is achieved using the <code>pkgVersion'</code> function, which parses the project manifest.</p></li>
</ul>
<p>That’s all. Further food of thoughts:</p>
<ul>
<li>Make the function work with everything, not just <code>hsenv</code></li>
<li>Remove the hardcoded name of the package, making it fully generic</li>
<li>Make the function to work against hsenv “named environments” (e.g. <code>.hsenv_myenv</code>)</li>
</ul>
<h2 id="references">References</h2>
<p>This is a collection of useful posts which helped me during my woes:</p>
<ul>
<li>http://neilmitchell.blogspot.it/2008/02/adding-data-files-using-cabal.html</li>
<li>http://comments.gmane.org/gmane.comp.lang.haskell.cafe/106000</li>
</ul>]]></summary>
</entry>
<entry>
    <title>State is Pure</title>
    <link href="http://www.alfredodinapoli.com/posts/2013-07-28-state-is-pure.html" />
    <id>http://www.alfredodinapoli.com/posts/2013-07-28-state-is-pure.html</id>
    <published>2013-07-28T00:00:00Z</published>
    <updated>2013-07-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Maybe (or maybe not) it happened to you at least once during your Haskell journey to look at functions like this…</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stackManip ::</span> <span class="dt">State</span> <span class="dt">Stack</span> <span class="dt">Int</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>stackManip <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  push <span class="dv">8</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  pop</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  pop</span></code></pre></div>
<p>…and to think: “How can possibly this work?” In this post I’ll desugar the <code>State</code> monad up to a point where all the other monads will go crazy screaming “Oh my God, it’s naked!”. But let’s start from the foundations.</p>
<h2 id="state-monad-at-the-speed-of-light">State monad at the speed of light</h2>
<p>The aim of this post is not teaching you how to use the <code>State</code> monad, I assume you are already familiar with it. Let’s first recall:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">State</span> s) <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> x <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> (x,s)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  m <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s <span class="ot">-&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>              <span class="kw">case</span> runState m s <span class="kw">of</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>                (x, s&#39;) <span class="ot">-&gt;</span> runState (f x) s&#39;</span></code></pre></div>
<p>This will be useful later on. For demonstration purposed I’m going to use a shameless copy of the stack examples you’ll find in <a href="http://learnyouahaskell.com/for-a-few-monads-more">Learn You a Haskell</a>, because it’s easy to grasp and perfect for our purposes. Let’s define a <code>Stack</code> as a type synonym for a list of <code>Int</code>, plus to stateful computations to push and pop stuff to/from the stack:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Stack</span> <span class="ot">=</span> [<span class="dt">Int</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">Stack</span> ()</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>push x <span class="ot">=</span> state <span class="op">$</span> \xs <span class="ot">-&gt;</span> ((), x<span class="op">:</span>xs)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ot">pop ::</span> <span class="dt">State</span> <span class="dt">Stack</span> <span class="dt">Int</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>pop <span class="ot">=</span> state <span class="op">$</span> \(x<span class="op">:</span>xs) <span class="ot">-&gt;</span> (x, xs)</span></code></pre></div>
<p>Armed with these two, we can write another stateful computation that modify the stack:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stackManip ::</span> <span class="dt">State</span> <span class="dt">Stack</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>stackManip <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  push <span class="dv">8</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  pop</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  pop</span></code></pre></div>
<p>And finally run the example:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">.</span> <span class="fu">show</span> <span class="op">$</span> runState stackManip [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">9</span>]</span></code></pre></div>
<p>This works. But how? In other terms, when I was a beginner Haskeller, this was the question I kept repeating to myself “Where is the state (the stack) passed around?” From my personal experience this often confuses newcomers, which might expect every function dealing with the state to take in input the “old” state in order to modify it. In other terms, this is what the newcomer expects:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">push&#39; ::</span> <span class="dt">Stack</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">Stack</span> ()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>push&#39; <span class="ot">=</span> <span class="fu">undefined</span> <span class="co">--not implemented</span></span></code></pre></div>
<p>And the fact that he sees just a stateful computation instead, without any “access point” for the old state to be passed in, confuses him. I’m going to shed light exactly over this.</p>
<h2 id="the-example-desugared">The example, desugared</h2>
<p>Let’s get back to our main for a moment:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">.</span> <span class="fu">show</span> <span class="op">$</span> runState stackManip [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">9</span>]</span></code></pre></div>
<p>In order to yield a result, we need to evaluate <code>stackManip</code>, so let’s take a look at it, again (<em>repetita iuvant</em>):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stackManip ::</span> <span class="dt">State</span> <span class="dt">Stack</span> <span class="dt">Int</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>stackManip <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  push <span class="dv">8</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  pop</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  pop</span></code></pre></div>
<p>We can easily rewrite the function without the do block, this way:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stackManip&#39; ::</span> <span class="dt">State</span> <span class="dt">Stack</span> <span class="dt">Int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>stackManip&#39; <span class="ot">=</span> push <span class="dv">8</span> <span class="op">&gt;&gt;</span> pop <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> pop</span></code></pre></div>
<p>We can now substitute the functions which their actual implementations:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stackManip&#39;&#39; ::</span> <span class="dt">State</span> <span class="dt">Stack</span> <span class="dt">Int</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>stackManip&#39;&#39; <span class="ot">=</span> (state <span class="op">$</span> \s <span class="ot">-&gt;</span> ((), <span class="dv">8</span><span class="op">:</span>s)) <span class="op">&gt;&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>               (state <span class="op">$</span> \(x<span class="op">:</span>xs) <span class="ot">-&gt;</span> (x,xs)) <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                state <span class="op">$</span> \(x&#39;<span class="op">:</span>xs&#39;) <span class="ot">-&gt;</span> (x&#39;,xs&#39;)</span></code></pre></div>
<p>Here I’ve already made a simplification: we already know what the new state for <code>push 8</code> will be: exactly the same we had at he beginning plus “8” on the top of the stack.</p>
<p>Now it’s time to recall how <code>(&gt;&gt;)</code> is defined in Haskell:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;) ::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>m1 <span class="op">&gt;&gt;</span> m2 <span class="ot">=</span> m1 <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> m2</span></code></pre></div>
<p>Which yield the following:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stackManip&#39;&#39;&#39; ::</span> <span class="dt">State</span> <span class="dt">Stack</span> <span class="dt">Int</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>stackManip&#39;&#39;&#39; <span class="ot">=</span> ((state <span class="op">$</span> \s <span class="ot">-&gt;</span> ((), <span class="dv">8</span><span class="op">:</span>s)) <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>                (state <span class="op">$</span> \(x<span class="op">:</span>xs) <span class="ot">-&gt;</span> (x,xs))) <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>                 state <span class="op">$</span> \(x&#39;<span class="op">:</span>xs&#39;) <span class="ot">-&gt;</span> (x&#39;,xs&#39;)</span></code></pre></div>
<p>If you look carefully, I’ve grouped on purpose the first two stateful computation, to stress the fact we are going to desugar something like this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>(op1 <span class="op">&gt;&gt;=</span> op2) <span class="op">&gt;&gt;=</span> op3</span></code></pre></div>
<p>And now the fun begins: we need to desugar even further <code>(&gt;&gt;=)</code>, with the definition I gave you at the beginning of the article:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stackManip&#39;&#39;&#39;&#39; ::</span> <span class="dt">State</span> <span class="dt">Stack</span> <span class="dt">Int</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>stackManip&#39;&#39;&#39;&#39; <span class="ot">=</span> (state <span class="op">$</span> \k <span class="ot">-&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> runState m k <span class="kw">of</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    (x, s&#39;) <span class="ot">-&gt;</span> runState (f x) s&#39;) <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  state <span class="op">$</span> \(x&#39;<span class="op">:</span>xs&#39;) <span class="ot">-&gt;</span> (x&#39;,xs&#39;)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    m <span class="ot">=</span> state <span class="op">$</span> \s <span class="ot">-&gt;</span> ((), <span class="dv">8</span><span class="op">:</span>s)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    f _ <span class="ot">=</span> state <span class="op">$</span> \(x&#39;&#39;<span class="op">:</span>xs&#39;&#39;) <span class="ot">-&gt;</span> (x&#39;&#39;, xs&#39;&#39;)</span></code></pre></div>
<p>The only thing I’ve done here to enforce readability is to move the two stateful computations we want to bind into two separate expressions, giving them a nomenclature similar to the familiar one (<code>m &gt;&gt;= f</code>). Let’s substitute further, getting rid of the case and of the first <code>runState</code>. I’m going to do two passages at once, but it’s mechanical if you follow the original implementation of <code>(&gt;&gt;=)</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sm&#39; ::</span> <span class="dt">State</span> <span class="dt">Stack</span> <span class="dt">Int</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>sm&#39; <span class="ot">=</span> (state <span class="op">$</span> \k <span class="ot">-&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>       runState (state <span class="op">$</span> \(x<span class="op">:</span>xs) <span class="ot">-&gt;</span> (x, xs)) (<span class="dv">8</span><span class="op">:</span>k)) <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>       state <span class="op">$</span> \(x&#39;&#39;<span class="op">:</span>xs&#39;&#39;) <span class="ot">-&gt;</span> (x&#39;&#39;, xs&#39;&#39;)</span></code></pre></div>
<p>Let’s simplify a bit the expression in the middle: <code>state</code> and <code>runState</code> and inverse of each other:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sm&#39;&#39; ::</span> <span class="dt">State</span> <span class="dt">Stack</span> <span class="dt">Int</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>sm&#39;&#39; <span class="ot">=</span> (state <span class="op">$</span> \k <span class="ot">-&gt;</span> (<span class="dv">8</span>,k)) <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        state <span class="op">$</span> \(x<span class="op">:</span>xs) <span class="ot">-&gt;</span> (x,xs)</span></code></pre></div>
<p>Much leaner! But now, unfortunately we’re going to beef up this once again, to get rid of the second bind. But hang thigh, once we do this we’ll have our final result:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sm&#39;&#39;&#39; ::</span> <span class="dt">State</span> <span class="dt">Stack</span> <span class="dt">Int</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>sm&#39;&#39;&#39; <span class="ot">=</span> state <span class="op">$</span> \q <span class="ot">-&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>         <span class="kw">case</span> runState (state <span class="op">$</span> \k <span class="ot">-&gt;</span> (<span class="dv">8</span>,k)) q <span class="kw">of</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>           (x,s&#39;) <span class="ot">-&gt;</span> runState (f x) s&#39;</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> f _ <span class="ot">=</span> state <span class="op">$</span> \(x&#39;<span class="op">:</span>xs&#39;) <span class="ot">-&gt;</span> (x&#39;,xs&#39;)</span></code></pre></div>
<p>It should not come as a surprise what I’ve done here: I’ve just applied again the definition of <code>(&gt;&gt;=)</code>, and moved the function to bind into a separate expression. It’s not time to simplify everything the way we did before (namely getting rid of the first <code>runState</code> and <code>case</code> expression):</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sm&#39;&#39;&#39;&#39; ::</span> <span class="dt">State</span> <span class="dt">Stack</span> <span class="dt">Int</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>sm&#39;&#39;&#39;&#39; <span class="ot">=</span> state <span class="op">$</span> \q <span class="ot">-&gt;</span> runState (state <span class="op">$</span> \(x<span class="op">:</span>xs) <span class="ot">-&gt;</span> (x,xs)) q</span></code></pre></div>
<p>And finally simplifying that expression we yield our final computation!</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">smFinal ::</span> <span class="dt">State</span> <span class="dt">Stack</span> <span class="dt">Int</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>smFinal <span class="ot">=</span> state <span class="op">$</span> \(q<span class="op">:</span>qs) <span class="ot">-&gt;</span> (q,qs)</span></code></pre></div>
<p>Well, this was somewhat expected, because pushing something and popping twice is equivalent to just pop once from the initial stack! Notice what happened: we started with a handful of “actions”, and we mechanically boiled them down to a single value! It’s now straightforward to see how this can work:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">.</span> <span class="fu">show</span> <span class="op">$</span> runState smFinal [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">9</span>]</span></code></pre></div>
<p>All we do is to extract a function from our <code>State</code> (with <code>runState</code>) and apply the underlying function to the initial stack. Nothing magical at all!</p>
<h2 id="do-i-need-to-worry-about-all-this-when-writing-my-programs">Do I need to worry about all this when writing my programs?</h2>
<p>I would say “hell no”! Is the abstraction which makes Haskell the wonderful language it is, so the compiler already does the “menial” job for you. All you need to do is to write your stateful computations with the idea that whatever you’ll write in a do block will be “sequenced” together and the state will be passed around as “functions applications”.</p>
<h2 id="conclusions">Conclusions</h2>
<p>I hope I was able to convey several messages:</p>
<ul>
<li><code>State</code> is pure, it’s just function application all over the place, in a CPS fashion.</li>
<li>You can’t write functions which takes the old state and yield a new stateful computation, because the state is already “trapped” in the stateful computation itself, and eventually all that function applications will boil down to a single function which takes your <strong>initial</strong> state and modify it as the computation proceeds.</li>
</ul>]]></summary>
</entry>
<entry>
    <title>Slick file download with Haskell in 40 SLOC</title>
    <link href="http://www.alfredodinapoli.com/posts/2013-07-20-slick-http-download-in-haskell.html" />
    <id>http://www.alfredodinapoli.com/posts/2013-07-20-slick-http-download-in-haskell.html</id>
    <published>2013-07-20T00:00:00Z</published>
    <updated>2013-07-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Lately I’ve submitted a <a href="https://github.com/tmhedberg/hsenv/pull/32">patch</a> to Hsenv featuring the ability to download a file over HTTP without external tools (e.g. curl), but using nothing more than awesome Haskell. I’ve posted the cool snippet on Reddit, and someone asked for a version with a progress bar, similar to what have been implemented in Python here:</p>
<p><a href="http://stackoverflow.com/a/22776">Download a file with Python - SO</a></p>
<p>I came up with a nice version which does rudimental error handling over HTTP response codes, which implements a progress bar and that has a constant memory usage, because we still retain all the benefits of programming with streaming libraries, namely <a href="http://hackage.haskell.org/package/io-streams">io-streams</a> and <a href="http://hackage.haskell.org/package/http-streams">http-streams</a>. Without further ado, let me show you the code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings, ScopedTypeVariables #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString</span> (<span class="dt">ByteString</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">C8</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO.Streams</span> (<span class="dt">InputStream</span>, <span class="dt">OutputStream</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.IO.Streams</span> <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.Http.Client</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.Socket</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Printf</span> (printf)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="ot">withProgressBar ::</span> <span class="dt">Integer</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                <span class="ot">-&gt;</span> <span class="dt">InputStream</span> <span class="dt">ByteString</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>                <span class="ot">-&gt;</span> <span class="dt">OutputStream</span> <span class="dt">ByteString</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>withProgressBar fileSize inS outS <span class="ot">=</span> go (<span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    go blocksRead <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>      block <span class="ot">&lt;-</span> S.read inS</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> block <span class="kw">of</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Just</span> d) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> currentBlocks <span class="ot">=</span> blocksRead <span class="op">+</span> B.length d</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> percentage <span class="ot">=</span> <span class="fu">fromIntegral</span> (currentBlocks <span class="op">*</span> <span class="dv">100</span>) <span class="op">/</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>                             <span class="fu">fromIntegral</span> fileSize</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>            printf <span class="st">&quot;%10d [%3.2f%%]\r&quot;</span> currentBlocks (<span class="ot">percentage ::</span> <span class="dt">Double</span>)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>            S.write (<span class="dt">Just</span> d) outS <span class="op">&gt;&gt;</span> go currentBlocks</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="ot">downloadFile ::</span> <span class="dt">URL</span> <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>downloadFile url name <span class="ot">=</span> withSocketsDo <span class="op">$</span> get url <span class="op">$</span> \response inStream <span class="ot">-&gt;</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> getStatusCode response <span class="kw">of</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>      <span class="dv">200</span> <span class="ot">-&gt;</span> <span class="kw">let</span> fileSize <span class="ot">=</span> <span class="fu">maybe</span> <span class="dv">0</span> (\fs <span class="ot">-&gt;</span> <span class="fu">read</span> (C8.unpack fs)<span class="ot"> ::</span> <span class="dt">Integer</span>)</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>                            (getHeader response <span class="st">&quot;Content-Length&quot;</span>)</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span> S.withFileAsOutput name (withProgressBar fileSize inStream)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>      code <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;Failed to download &quot;</span> <span class="op">++</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>                      name <span class="op">++</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>                      <span class="st">&quot;: http response returned &quot;</span> <span class="op">++</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>                      <span class="fu">show</span> code</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> url <span class="ot">=</span> <span class="st">&quot;http://audacity.googlecode.com/files/audacity-macosx-ub-2.0.3.dmg&quot;</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> <span class="st">&quot;Downloading &quot;</span> <span class="op">++</span> url</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>  downloadFile (C8.pack url) <span class="st">&quot;audacity.dmg&quot;</span></span></code></pre></div>
<p>As you can see, it’s less than 40 lines of code! (ok, a bit more, but just because I’ve splitted the type signature and the error message on multiple lines to make it fit the blog template). Even better, as someone suggested on Reddit, we can make this code multi-platform using <code>withSocketsDo</code> before <code>get</code>. We need this on Windows machines only (to initialize the underlying socket), but due to the fact <code>withSocketsDo</code> is implemented as <code>id</code> on *nix platforms, everything will just work. Once again, Haskell rocks.</p>]]></summary>
</entry>
<entry>
    <title>Demand more from your programming language</title>
    <link href="http://www.alfredodinapoli.com/posts/2013-02-10-demand-more-from-your-programming-language.html" />
    <id>http://www.alfredodinapoli.com/posts/2013-02-10-demand-more-from-your-programming-language.html</id>
    <published>2013-02-10T00:00:00Z</published>
    <updated>2013-02-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>First of all, this is not a post about “Your language is better than yours”. No. So no flame war incoming. This is simply a post about some simple concept in Haskell that sometimes we (at least I) forgot because I give them away as “granted”, but that can be extremely useful for the newcomer. This post is shameless rumination of part of the excellent talk Doug Beardsley gave at NYC Haskell meetup.</p>
<h3 id="we-live-in-an-imperfect-world">We live in an imperfect world</h3>
<p>As the great programmer he was, Edsger Dijkstra once said <em>“If debugging is the process of removing software bugs, then programming must be the process of putting them in”</em>. This may sound hilarious at first, but I believe is incredibly true! We are humans, and we will always made mistakes; because we are not focused enough, because we are tired or bored for a particular task, because we are distracted by a funny joke of a colleague in the middle of a coding session, or “put your favourite reason here”. The point is, that is difficult sometimes to get things right, so we want the machines (namely our computer!) do double check for us, getting rid of some obnoxious bug we could be not aware of or just missed in our programming frenzy.</p>
<h3 id="the-dynamic-languages">The dynamic languages</h3>
<p>Dynamic languages have tons of excellent features (they are pragmatic, allow rapid prototyping etc etc) and I still love hacking with Python with a have a simple script to code or I want to do something programmatically (e.g. parse a text file, manipulate it, show some stuff, rinse and repeat), but they most of the times lacks a sophisticated type system to help us catch bugs. Granted, they <em>do</em> have sophisticated mechanism under the hood to do type inference, but this is not the point I want to make. Take this excerpt of python code, I had in production for a while:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Transaction:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, <span class="bu">id</span>):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   <span class="va">self</span>._id <span class="op">=</span> <span class="bu">id</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  [...]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> warn_user_about_unprocessed_transaction(transaction):</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  send_email(transaction.<span class="bu">id</span>)</span></code></pre></div>
<p>Now, what happened is that, unsurprisingly enough, this code is risky. I won’t insult your intelligence with another dissertation about type safety, but too often I ended up doing something stupid like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>[...]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>transaction <span class="op">=</span> myobj.<span class="bu">id</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>warn_user_about_unprocessed_transaction(transaction)</span></code></pre></div>
<p>Granted, this is stupid code, but when you fiddle with an ORM and IDs is easy to confuse the object id from its whole representation. The scariest thing is that this thing will fail only when I will hit that code for the first time! Again, there are some excellent static analysis tools over there, but they sometimes does not work too well. The point here is that we are kinda walking on a mine field; we don’t have type signature (Python3 makes them optional, which is a good thing!) and worst of all we tend to not trust our code anymore, because we have to put a lot of extra effort in ensuring we are passing the correct type to every function!</p>
<h3 id="strongly-typed-languages-at-rescue">Strongly typed languages at rescue</h3>
<p>Now, suppose we were writing the same in Java/C/C++ or whatever programming strongly typed programming language. Here the compiler gives us an invaluable help in catching stupids bugs like the one just shown. The classic objection (which I subscribe!) is that they are far too verbose and the type system sometimes really clutters your code (think about Java’s checked exception and your monolithic function signatures!). But whether hardware and technology evolves, the <em>way</em> we build software seems to have reached a plateau. How come we are using the same technology and imperative techniques of more than 30 years ago? Can we do better? Well, we functional programming zealots think we can.</p>
<h3 id="functional-programming-and-purity">Functional programming and purity</h3>
<p>Sometimes we forget that functional programming focuses on two different aspects:</p>
<ul>
<li><p>Purity</p></li>
<li><p>Type safety</p></li>
</ul>
<p>While the second is something we can achieve also with the imperative languages, types are a totally different kettle of fish in the FP land. The type system is <strong>a tool</strong> to explore the design space of a new piece of software. When we replace interfaces with functions, we see a sort of “pipe system” emerging, when we focus not on <strong>how</strong> do something (think about recipe, do step A, then step B, etc) but <strong>which transformations</strong> are required to produce the desired result. By “pipe system” here I mean a system composed by pipes and junctions which connect two pipes together. Our pipe is a function, the junction is the type signature. We can only attach a pipe to another one only if the junction shape matches. If we weren’t doing so, our pipe would leak! Is not difficult to see where this analogy bring us. The <em>leaking</em> is the concept of state! Being <em>sure</em> that our pipe won’t do anything “stupid” with our input data make us more confident about the outcome, while the type system take care of us that, even before putting the water inside the pipe (namely the “runtime computation flow”). Is like if a plumber would come and check for us the entire pipework, saying “Ah! Here the is a leak, you are using two pipes with different junctions!”. If our plumber says “Ok, it’s safe to go”, we can open the tap and let the water go through our system, without worrying that the pipework will break suddenly, making the entire water go lost. Now, bear in mind one fundamental thing: I’m not saying anything about the result, I’m not telling you that acting this way will save us from all the bugs, this is simply impossible, I’m just saying that this will save you from having a leaking pipe, that’s all!</p>
<p>Now we compared the type system and the compiler to a plumber which ensure our pipe don’t leak; but pipes can leaks for different reasons! Imagine that we have our pipe perfectly sealed, with all the junctions perfectly aligned. If you think about this, this is something we could achieve also in an imperative language and, being provocative, also in Scala! After all, Scala has an excellent type system, so we would expect that program in Scala should never leak, right? Well, unfortunately is not the case. Scala programs <em>may leak</em> but not of a “junction” leaking. Here’s where purity comes into play.</p>
<h2 id="being-pure-with-haskell">Being pure with Haskell</h2>
<p>Now, imagine this scenario. Your pipework, along the way, has something unexpected. The pipes goes inside another premise we don’t have the control over our pipework anymore. While inside the premise, another plumber decide to modify our pipe, insert a special water cleaner and then “re-inject” the water inside the old pipe system. Wait, we have side effect! How is that possible? We have type safety, the world should be a better place to live, shouldn’t it? Well, type safety helps, but purity is the big winner here. Being pure means <strong>clearly separates</strong> what is pure from what is not, or, to say it in another way, separate <strong>the context</strong> from the data. Not going inside the details, because this is something I don’t to turn this stream of thoughts in a tutorial, but this is pretty much the essence of <strong>monads</strong>. Monads are like a special “case” we put around our pipes: have you seen electrical cables? They have different colors based on what their function is; a ground cable will have a different color from the main one. That’s it: electrical cable have different color to put them in <strong>different context</strong>. We will do the same with our pipes; we’ll wrap them with a special case, every case with a special color and with special rules; “naked” pipes cannot be touched for their entire lifetime. This means that the “plumber worldwide association” agrees that they will never touch a naked pipe: the only plumber entitled to do it is the one who originally build the pipework. Then they could agree that pipes with a red case can be modified but with a special constrain; the can <em>never</em> lose the original case and color. In a nutshell, once we wrap our pipe inside a red case, we <strong>cannot</strong> turn them into a green pipe or a naked one, we can’t lose the information about the pipe being a red one!</p>
<h2 id="how-the-hell-this-is-relevant">How the hell this is relevant?</h2>
<p>If you keep up with my example, you have pretty much understood what a monad is about. So let’s turn this inside sexy Haskell code and you’ll have your “a-ha!” moment, I promise. Let’s start with this code:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ot">square ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>square x <span class="ot">=</span> x <span class="op">*</span> x</span></code></pre></div>
<p>Ladies and gentlemen, the <strong>naked</strong> pipe. See the clutter-free signature? We are saying that we have no context around us, this function is <strong>pure</strong>. We are <strong>guaranteed</strong> that this function will <strong>never</strong> talk to the outside world. It’s just pure, plain water flowing inside our pipe. Now let me show you this overly-verbose example, just for teaching purposes:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">getName ::</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>getName <span class="ot">=</span> <span class="fu">getLine</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    name <span class="ot">&lt;-</span> getName</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="st">&quot;Hello &quot;</span> <span class="op">++</span> name</span></code></pre></div>
<p>This get your name from the stdin and greets you. Oh! See that fancy <code>IO String</code>? Is the red pipe! Without getting too deep inside the details (tons of tutorials out there explaining all you need to do about monads) we put a special “red case”, called <code>IO</code> around our naked pipe. Now we know, simply looking at this function that <code>getName</code> is a function of a special breed, it can talk to the outside world! It could talk to the DB, getting involved in weird thread contentions or fire up a missile to destroy the world. But the point is that, just like the “plumber worldwide association” agreed, you can’t remove this “case” from your function. It’s just like a sort of masonic motto:</p>
<div class="glance-box" data-markdown="1">
<p>“What happens in the IO monad, stays in the IO monad!”</p>
</div>
<p><br></p>
<p>In other terms, we can’t “escape” from the IO monad, now to use this function we have only two choices:</p>
<ul>
<li><p>Use this in isolation, but we can’t coerce an <code>IO String</code> back to a <code>String</code></p></li>
<li><p>Use this only together with other red pipes! (like we did calling it from <code>main</code>)</p></li>
</ul>
<p>See the wonderful pattern which is emerging? Now we have safety a type level, namely our junctions, but context-safety thanks to different “case”! So now we have a nice pipe, with all the junctions perfectly fitting and colored of a shine red all way down. Much better.</p>
<p>Compare this with, for example, Scala:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">square</span><span class="op">(</span>n1<span class="op">:</span> Double<span class="op">,</span> n2<span class="op">:</span> Double<span class="op">):</span> Double <span class="op">=</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutateTheWorld</span><span class="op">();</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sendMissileToMars</span><span class="op">();</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  n1 <span class="op">*</span> n2</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In Scala, and in every other programming languages without monads (and its derivatives) we can only ensure our pipe won’t leak, not that our pipe won’t be modified.</p>
<p>That’s <strong>one</strong> of the power of monads. This is one of the power of Haskell.</p>]]></summary>
</entry>
<entry>
    <title>Scalaz for the Haskell programmer - Part 1</title>
    <link href="http://www.alfredodinapoli.com/posts/2012-10-31-scalaz-for-the-haskell-programmer.html" />
    <id>http://www.alfredodinapoli.com/posts/2012-10-31-scalaz-for-the-haskell-programmer.html</id>
    <published>2012-10-31T00:00:00Z</published>
    <updated>2012-10-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://github.com/scalaz/scalaz">scalaz</a> is an awesome library that extends the Scala Core, providing FP goodies that every Haskell programmer loves and needs. Yes, I’m obviously talking about <code>Functors</code>, <code>Monads</code> and other strange beasts from the Category Theory panorama. There is a lot of learning material for scalaz, but I’ve basically discovered that is not easy to organize your thoughts if you are an Haskell programmer, so I’m basically just writing this primarily as a mental note, but I hope it will be useful for others too. The tutorial will be focused on <strong>scalaz 7</strong>, so be wary if you are not planning to switching any time soon. Before we start, I’ve found this little gem that compares, side by side, a lot of features from different programming languages:</p>
<div data-align="center" data-markdown="1">
<p><a href="http://hyperpolyglot.org/ml">Hyperpolyglot cheatsheet</a></p>
</div>
<h3 id="setting-up-an-sbt-project">Setting up an sbt project</h3>
<p>If you are lazy and want to start right away, I suggest you use my <a href="https://github.com/adinapoli/scalaz-revolver.g8">giter8 template</a> to have a plain project with scalaz and <a href="https://github.com/spray/sbt-revolver">sbt-revolver</a>. The template also imports for you scalaz in the sbt console, so you can start playing right away.</p>
<h3 id="monads-and-control.monad-functions">Monads and Control.Monad functions</h3>
<p>Most tutorials starts with <code>Typeclasses</code>, data structures declaration or other important aspects. Here, I want to start from Haskell’s main draw, <code>Monads</code>. This should be familiar:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">some</span><span class="op">(</span><span class="dv">3</span><span class="op">)</span> <span class="op">&gt;&gt;=</span> <span class="op">(</span>x <span class="op">=&gt;</span> <span class="fu">some</span><span class="op">(</span>x<span class="op">+</span><span class="dv">1</span><span class="op">))</span> <span class="co">//yields some(4)</span></span></code></pre></div>
<p>Unsurprisingly, it returns <code>some(4)</code>. It this code is not straightforward to you, you won’t find the monad part covedered. This is only a sort of “quick mental mapping” for the Haskell programmer that wants to program in a more functional oriented way in Scala. This code should be familiar too:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">some</span><span class="op">(</span><span class="dv">3</span><span class="op">)</span> <span class="op">&gt;&gt;</span> <span class="fu">some</span><span class="op">(</span><span class="dv">4</span><span class="op">)</span> <span class="co">//yields some(4)</span></span></code></pre></div>
<p>Remember how <code>(&gt;&gt;)</code> is defined in Haskell:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;) ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m b</span></code></pre></div>
<h4 id="replicatem">replicateM</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">replicateM ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m [a]</span></code></pre></div>
<p>Has its equivalent in:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">some</span><span class="op">(</span><span class="dv">2</span><span class="op">)</span> replicateM <span class="dv">3</span> <span class="co">// yields some(List(2,2,2))</span></span></code></pre></div>
<p>As you can notice the syntax is not as terse an in Haskell, due to the nature of the two languages; in Scala, everything is an object, and Haskell behaviors are simulated using <code>traits</code>. This obviously force the programmer to write code that resemble method invocations. When allowed, I always prefer the “dot-free” syntax (like the example above), because give the code a more functional look.</p>
<h4 id="filterm">filterM</h4>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">filterM ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">List</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">)</span> filterM <span class="op">{</span> x <span class="op">=&gt;</span> <span class="fu">some</span><span class="op">(</span>x <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)}</span> <span class="co">//yields some(List(2))</span></span></code></pre></div>
<p>It would have been nice to have the Haskell’s equivalent of <code>return</code>, but I wasn’t able to find nothing like that in scalaz. If you are aware of something different, please let me know, I will be happy to update this post.</p>
<h3 id="functors">Functors</h3>
<p>Another important tool in the functional programmer belt are functors. They are supported in scalaz too (it’s obvious, because <code>Monads</code> are <code>Functors</code>, so it scalaz supports <code>Monads</code>, why not <code>Functors</code>?). scalaz’s developers have decided to polish a bit the syntax, so you have to call <code>map</code> instead of <code>fmap</code>. You may or may not like this choice:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">some</span><span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="fu">map</span> <span class="op">(</span>x <span class="op">=&gt;</span> x <span class="op">*</span> x<span class="op">)</span> <span class="co">//yields some(4)</span></span></code></pre></div>
<h3 id="applicative">Applicative</h3>
<p>In layman’s terms, we can call an <code>Applicative</code> a <code>Functor</code> on steroid. In Haskell, it’s very common to use them to aggregate results of a non-deterministic computation. Take a look to this piece of Haskell code, that can be quite mind-blowing for the apprentice functional programmer:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span>) <span class="op">&lt;$&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="op">&lt;*&gt;</span> [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</span></code></pre></div>
<p>This yields all the possible combination of summing the values from the to lists together. In this case we obtain the list <code>[5,6,7,6,7,8,7,8,9]</code>. In Scala, we can obtain the same result with this syntax:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span><span class="bu">List</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">)</span> <span class="op">|</span>@<span class="op">|</span> <span class="bu">List</span><span class="op">(</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span><span class="op">))</span> <span class="op">{</span> _ <span class="op">+</span> _ <span class="op">}</span></span></code></pre></div>
<p>Where <code>|@|</code> yields an <code>ApplicativeBuilder</code> (I’m not enough proficient with scalaz to speculate about this design choice).</p>
<h3 id="monoid">Monoid</h3>
<p>In Haskell, the two most important function every <code>Monoid</code> has are <code>mempty</code> and <code>mappend</code>. In scalaz you have <code>mzero</code> and <code>|+|</code> instead:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mempty</span><span class="ot"> ::</span> (<span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> a</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mappend</span><span class="ot"> ::</span> (<span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mempty</span><span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="co">--returns an empty list</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>] <span class="ot">`mappend`</span> [<span class="dv">3</span>,<span class="dv">4</span>] <span class="co">-- [1,2,3,4]</span></span></code></pre></div>
<p>This is roughly the equivalent in Scala:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>mzero<span class="op">[</span><span class="bu">List</span><span class="op">[</span><span class="bu">Int</span><span class="op">]]</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="bu">List</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">)</span> <span class="op">|+|</span> <span class="bu">List</span><span class="op">(</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">)</span></span></code></pre></div>
<p>Well, I have to say that amoung all the scalaz stuff, the <code>Monoid</code> part is what I like less. Why? Because it doesn’t stick with the original Haskell and matchematical definition. Wolfram MathWorld sais that:</p>
<div class="glance-box">
<p>A monoid is a set that is closed under an associative binary operation and has an identity element[…]</p>
</div>
<p><br></p>
<p>In layman’s terms, every <code>Monoid</code> is defined respect to an operation. This explain why an <code>Int</code> can’t be a <code>Monoid</code> per se: which operation should we consider? <code>+</code> or <code>*</code>? You can prove this trying to ask Haskell for the “zero value” of an <code>Int</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mempty</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">Monoid</span> <span class="dt">Int</span>) <span class="op">...</span></span></code></pre></div>
<p>And the same applies for <code>mappend</code>: how can Haskell know how to append two <code>Int</code>?</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span> <span class="ot">`mappend`</span> <span class="dv">4</span></span></code></pre></div>
<p>To solve this, we wrap our <code>Int</code>(s) in types that are instances of <code>Monoid</code>, for example <code>Sum</code> and <code>Product</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mempty</span><span class="ot"> ::</span> <span class="dt">Sum</span> <span class="dt">Int</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Sum</span> {getSum <span class="ot">=</span> <span class="dv">0</span>}</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="fu">mempty</span><span class="ot"> ::</span> <span class="dt">Product</span> <span class="dt">Int</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Product</span> {getProduct <span class="ot">=</span> <span class="dv">1</span>}</span></code></pre></div>
<p>Now, with this formalism, we can <code>mappend</code> our <code>Monoid</code>, because now we have an operation that characterize the <code>Monoid</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Sum</span> <span class="dv">4</span> <span class="ot">`mappend`</span> <span class="dt">Sum</span> <span class="dv">5</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Sum</span> {getSum <span class="ot">=</span> <span class="dv">9</span>}</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Product</span> <span class="dv">4</span> <span class="ot">`mappend`</span> <span class="dt">Product</span> <span class="dv">4</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Product</span> {getProduct <span class="ot">=</span> <span class="dv">16</span>}</span></code></pre></div>
<p>Conversely, Scala is not so strict, and allows us to do this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dv">9</span> <span class="op">|+|</span> <span class="dv">15</span></span></code></pre></div>
<p>Which I don’t like very much. (To the expert reader? What am I missing? Maybe is <code>|+|</code> an alias for a <code>Monoid</code> closed on <code>+</code>?)</p>
<h3 id="pipelines-and-function-composition">Pipelines and function composition</h3>
<p>This actually isn’t an Haskell features, but for example F# has the nice pipeline operator <code>(|&gt;)</code> to give the code a dataflow structure. You can use the pipeline operator to implement function composition as well:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">floor</span> <span class="op">.</span> <span class="fu">sqrt</span> <span class="op">$</span> <span class="dv">10</span> <span class="co">--equivalent to floor(sqrt(10))</span></span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fl">10.0</span> <span class="op">|&gt;</span> sqrt <span class="op">|&gt;</span> floor <span class="co">//yields 3.0</span></span></code></pre></div>
<p>As you can see, the computation “flows” into two different ways: in the former example from right to left, in the latter from left to right, but the result is the same. A nice that we got for free here is a bit more of type safety: whilst Haskell accept the above code, Scala refuses to compile due to a type mismatch, if we pass <code>10</code> to the pipeline operator. Nice.</p>
<h2 id="conclusions">Conclusions</h2>
<p>This first part was dense, but also useful to get myself acquainted with scalaz. There is still a lot to cover (for example <code>Comonad</code>, <code>Arrow</code> and more), so there is room for a part 2. I think scalaz has a lot of potentials, and I’ll be happy to use in a project if I have the chance. I believe it helps to get rid of the “OO-flavor” Scala inherited from its Java vestiges. Before the farewell, take a look at this two blog post, that I’ve read to gather part of the material from <code>Applicative</code> and <code>Monoid</code>:</p>
<ul>
<li><a href="http://www.casualmiracles.com/2012/01/16/a-small-example-of-applicative-functors-with-scalaz/">A Small Example of Applicative Functors with Scalaz</a></li>
<li><a href="http://voidmainargs.blogspot.it/2012/02/having-fun-with-monoid-in-scalaz-seven.html">Having Fun with Monoid in Scalaz Seven</a></li>
</ul>
<p>Happy hacking!</p>]]></summary>
</entry>

</feed>
