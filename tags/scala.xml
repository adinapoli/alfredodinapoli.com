<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Alfredo Di Napoli's Tech Blog</title>
    <link href="http://www.alfredodinapoli.com/tags/scala.xml" rel="self" />
    <link href="http://www.alfredodinapoli.com" />
    <id>http://www.alfredodinapoli.com/tags/scala.xml</id>
    <author>
        <name>Alfredo Di Napoli</name>
        <email>alfredo.dinapoli@gmail.com</email>
    </author>
    <updated>2013-02-10T00:00:00Z</updated>
    <entry>
    <title>Demand more from your programming language</title>
    <link href="http://www.alfredodinapoli.com/posts/2013-02-10-demand-more-from-your-programming-language.html" />
    <id>http://www.alfredodinapoli.com/posts/2013-02-10-demand-more-from-your-programming-language.html</id>
    <published>2013-02-10T00:00:00Z</published>
    <updated>2013-02-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>First of all, this is not a post about “Your language is better than yours”. No. So no flame war incoming. This is simply a post about some simple concept in Haskell that sometimes we (at least I) forgot because I give them away as “granted”, but that can be extremely useful for the newcomer. This post is shameless rumination of part of the excellent talk Doug Beardsley gave at NYC Haskell meetup.</p>
<h3 id="we-live-in-an-imperfect-world">We live in an imperfect world</h3>
<p>As the great programmer he was, Edsger Dijkstra once said <em>“If debugging is the process of removing software bugs, then programming must be the process of putting them in”</em>. This may sound hilarious at first, but I believe is incredibly true! We are humans, and we will always made mistakes; because we are not focused enough, because we are tired or bored for a particular task, because we are distracted by a funny joke of a colleague in the middle of a coding session, or “put your favourite reason here”. The point is, that is difficult sometimes to get things right, so we want the machines (namely our computer!) do double check for us, getting rid of some obnoxious bug we could be not aware of or just missed in our programming frenzy.</p>
<h3 id="the-dynamic-languages">The dynamic languages</h3>
<p>Dynamic languages have tons of excellent features (they are pragmatic, allow rapid prototyping etc etc) and I still love hacking with Python with a have a simple script to code or I want to do something programmatically (e.g. parse a text file, manipulate it, show some stuff, rinse and repeat), but they most of the times lacks a sophisticated type system to help us catch bugs. Granted, they <em>do</em> have sophisticated mechanism under the hood to do type inference, but this is not the point I want to make. Take this excerpt of python code, I had in production for a while:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Transaction:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, <span class="bu">id</span>):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   <span class="va">self</span>._id <span class="op">=</span> <span class="bu">id</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  [...]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> warn_user_about_unprocessed_transaction(transaction):</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  send_email(transaction.<span class="bu">id</span>)</span></code></pre></div>
<p>Now, what happened is that, unsurprisingly enough, this code is risky. I won’t insult your intelligence with another dissertation about type safety, but too often I ended up doing something stupid like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>[...]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>transaction <span class="op">=</span> myobj.<span class="bu">id</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>warn_user_about_unprocessed_transaction(transaction)</span></code></pre></div>
<p>Granted, this is stupid code, but when you fiddle with an ORM and IDs is easy to confuse the object id from its whole representation. The scariest thing is that this thing will fail only when I will hit that code for the first time! Again, there are some excellent static analysis tools over there, but they sometimes does not work too well. The point here is that we are kinda walking on a mine field; we don’t have type signature (Python3 makes them optional, which is a good thing!) and worst of all we tend to not trust our code anymore, because we have to put a lot of extra effort in ensuring we are passing the correct type to every function!</p>
<h3 id="strongly-typed-languages-at-rescue">Strongly typed languages at rescue</h3>
<p>Now, suppose we were writing the same in Java/C/C++ or whatever programming strongly typed programming language. Here the compiler gives us an invaluable help in catching stupids bugs like the one just shown. The classic objection (which I subscribe!) is that they are far too verbose and the type system sometimes really clutters your code (think about Java’s checked exception and your monolithic function signatures!). But whether hardware and technology evolves, the <em>way</em> we build software seems to have reached a plateau. How come we are using the same technology and imperative techniques of more than 30 years ago? Can we do better? Well, we functional programming zealots think we can.</p>
<h3 id="functional-programming-and-purity">Functional programming and purity</h3>
<p>Sometimes we forget that functional programming focuses on two different aspects:</p>
<ul>
<li><p>Purity</p></li>
<li><p>Type safety</p></li>
</ul>
<p>While the second is something we can achieve also with the imperative languages, types are a totally different kettle of fish in the FP land. The type system is <strong>a tool</strong> to explore the design space of a new piece of software. When we replace interfaces with functions, we see a sort of “pipe system” emerging, when we focus not on <strong>how</strong> do something (think about recipe, do step A, then step B, etc) but <strong>which transformations</strong> are required to produce the desired result. By “pipe system” here I mean a system composed by pipes and junctions which connect two pipes together. Our pipe is a function, the junction is the type signature. We can only attach a pipe to another one only if the junction shape matches. If we weren’t doing so, our pipe would leak! Is not difficult to see where this analogy bring us. The <em>leaking</em> is the concept of state! Being <em>sure</em> that our pipe won’t do anything “stupid” with our input data make us more confident about the outcome, while the type system take care of us that, even before putting the water inside the pipe (namely the “runtime computation flow”). Is like if a plumber would come and check for us the entire pipework, saying “Ah! Here the is a leak, you are using two pipes with different junctions!”. If our plumber says “Ok, it’s safe to go”, we can open the tap and let the water go through our system, without worrying that the pipework will break suddenly, making the entire water go lost. Now, bear in mind one fundamental thing: I’m not saying anything about the result, I’m not telling you that acting this way will save us from all the bugs, this is simply impossible, I’m just saying that this will save you from having a leaking pipe, that’s all!</p>
<p>Now we compared the type system and the compiler to a plumber which ensure our pipe don’t leak; but pipes can leaks for different reasons! Imagine that we have our pipe perfectly sealed, with all the junctions perfectly aligned. If you think about this, this is something we could achieve also in an imperative language and, being provocative, also in Scala! After all, Scala has an excellent type system, so we would expect that program in Scala should never leak, right? Well, unfortunately is not the case. Scala programs <em>may leak</em> but not of a “junction” leaking. Here’s where purity comes into play.</p>
<h2 id="being-pure-with-haskell">Being pure with Haskell</h2>
<p>Now, imagine this scenario. Your pipework, along the way, has something unexpected. The pipes goes inside another premise we don’t have the control over our pipework anymore. While inside the premise, another plumber decide to modify our pipe, insert a special water cleaner and then “re-inject” the water inside the old pipe system. Wait, we have side effect! How is that possible? We have type safety, the world should be a better place to live, shouldn’t it? Well, type safety helps, but purity is the big winner here. Being pure means <strong>clearly separates</strong> what is pure from what is not, or, to say it in another way, separate <strong>the context</strong> from the data. Not going inside the details, because this is something I don’t to turn this stream of thoughts in a tutorial, but this is pretty much the essence of <strong>monads</strong>. Monads are like a special “case” we put around our pipes: have you seen electrical cables? They have different colors based on what their function is; a ground cable will have a different color from the main one. That’s it: electrical cable have different color to put them in <strong>different context</strong>. We will do the same with our pipes; we’ll wrap them with a special case, every case with a special color and with special rules; “naked” pipes cannot be touched for their entire lifetime. This means that the “plumber worldwide association” agrees that they will never touch a naked pipe: the only plumber entitled to do it is the one who originally build the pipework. Then they could agree that pipes with a red case can be modified but with a special constrain; the can <em>never</em> lose the original case and color. In a nutshell, once we wrap our pipe inside a red case, we <strong>cannot</strong> turn them into a green pipe or a naked one, we can’t lose the information about the pipe being a red one!</p>
<h2 id="how-the-hell-this-is-relevant">How the hell this is relevant?</h2>
<p>If you keep up with my example, you have pretty much understood what a monad is about. So let’s turn this inside sexy Haskell code and you’ll have your “a-ha!” moment, I promise. Let’s start with this code:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ot">square ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>square x <span class="ot">=</span> x <span class="op">*</span> x</span></code></pre></div>
<p>Ladies and gentlemen, the <strong>naked</strong> pipe. See the clutter-free signature? We are saying that we have no context around us, this function is <strong>pure</strong>. We are <strong>guaranteed</strong> that this function will <strong>never</strong> talk to the outside world. It’s just pure, plain water flowing inside our pipe. Now let me show you this overly-verbose example, just for teaching purposes:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">getName ::</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>getName <span class="ot">=</span> <span class="fu">getLine</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    name <span class="ot">&lt;-</span> getName</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="st">&quot;Hello &quot;</span> <span class="op">++</span> name</span></code></pre></div>
<p>This get your name from the stdin and greets you. Oh! See that fancy <code>IO String</code>? Is the red pipe! Without getting too deep inside the details (tons of tutorials out there explaining all you need to do about monads) we put a special “red case”, called <code>IO</code> around our naked pipe. Now we know, simply looking at this function that <code>getName</code> is a function of a special breed, it can talk to the outside world! It could talk to the DB, getting involved in weird thread contentions or fire up a missile to destroy the world. But the point is that, just like the “plumber worldwide association” agreed, you can’t remove this “case” from your function. It’s just like a sort of masonic motto:</p>
<div class="glance-box" data-markdown="1">
<p>“What happens in the IO monad, stays in the IO monad!”</p>
</div>
<p><br></p>
<p>In other terms, we can’t “escape” from the IO monad, now to use this function we have only two choices:</p>
<ul>
<li><p>Use this in isolation, but we can’t coerce an <code>IO String</code> back to a <code>String</code></p></li>
<li><p>Use this only together with other red pipes! (like we did calling it from <code>main</code>)</p></li>
</ul>
<p>See the wonderful pattern which is emerging? Now we have safety a type level, namely our junctions, but context-safety thanks to different “case”! So now we have a nice pipe, with all the junctions perfectly fitting and colored of a shine red all way down. Much better.</p>
<p>Compare this with, for example, Scala:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">square</span><span class="op">(</span>n1<span class="op">:</span> Double<span class="op">,</span> n2<span class="op">:</span> Double<span class="op">):</span> Double <span class="op">=</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutateTheWorld</span><span class="op">();</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sendMissileToMars</span><span class="op">();</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  n1 <span class="op">*</span> n2</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In Scala, and in every other programming languages without monads (and its derivatives) we can only ensure our pipe won’t leak, not that our pipe won’t be modified.</p>
<p>That’s <strong>one</strong> of the power of monads. This is one of the power of Haskell.</p>]]></summary>
</entry>
<entry>
    <title>Scalaz for the Haskell programmer - Part 1</title>
    <link href="http://www.alfredodinapoli.com/posts/2012-10-31-scalaz-for-the-haskell-programmer.html" />
    <id>http://www.alfredodinapoli.com/posts/2012-10-31-scalaz-for-the-haskell-programmer.html</id>
    <published>2012-10-31T00:00:00Z</published>
    <updated>2012-10-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://github.com/scalaz/scalaz">scalaz</a> is an awesome library that extends the Scala Core, providing FP goodies that every Haskell programmer loves and needs. Yes, I’m obviously talking about <code>Functors</code>, <code>Monads</code> and other strange beasts from the Category Theory panorama. There is a lot of learning material for scalaz, but I’ve basically discovered that is not easy to organize your thoughts if you are an Haskell programmer, so I’m basically just writing this primarily as a mental note, but I hope it will be useful for others too. The tutorial will be focused on <strong>scalaz 7</strong>, so be wary if you are not planning to switching any time soon. Before we start, I’ve found this little gem that compares, side by side, a lot of features from different programming languages:</p>
<div data-align="center" data-markdown="1">
<p><a href="http://hyperpolyglot.org/ml">Hyperpolyglot cheatsheet</a></p>
</div>
<h3 id="setting-up-an-sbt-project">Setting up an sbt project</h3>
<p>If you are lazy and want to start right away, I suggest you use my <a href="https://github.com/adinapoli/scalaz-revolver.g8">giter8 template</a> to have a plain project with scalaz and <a href="https://github.com/spray/sbt-revolver">sbt-revolver</a>. The template also imports for you scalaz in the sbt console, so you can start playing right away.</p>
<h3 id="monads-and-control.monad-functions">Monads and Control.Monad functions</h3>
<p>Most tutorials starts with <code>Typeclasses</code>, data structures declaration or other important aspects. Here, I want to start from Haskell’s main draw, <code>Monads</code>. This should be familiar:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">some</span><span class="op">(</span><span class="dv">3</span><span class="op">)</span> <span class="op">&gt;&gt;=</span> <span class="op">(</span>x <span class="op">=&gt;</span> <span class="fu">some</span><span class="op">(</span>x<span class="op">+</span><span class="dv">1</span><span class="op">))</span> <span class="co">//yields some(4)</span></span></code></pre></div>
<p>Unsurprisingly, it returns <code>some(4)</code>. It this code is not straightforward to you, you won’t find the monad part covedered. This is only a sort of “quick mental mapping” for the Haskell programmer that wants to program in a more functional oriented way in Scala. This code should be familiar too:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">some</span><span class="op">(</span><span class="dv">3</span><span class="op">)</span> <span class="op">&gt;&gt;</span> <span class="fu">some</span><span class="op">(</span><span class="dv">4</span><span class="op">)</span> <span class="co">//yields some(4)</span></span></code></pre></div>
<p>Remember how <code>(&gt;&gt;)</code> is defined in Haskell:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;) ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m b</span></code></pre></div>
<h4 id="replicatem">replicateM</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">replicateM ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m [a]</span></code></pre></div>
<p>Has its equivalent in:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">some</span><span class="op">(</span><span class="dv">2</span><span class="op">)</span> replicateM <span class="dv">3</span> <span class="co">// yields some(List(2,2,2))</span></span></code></pre></div>
<p>As you can notice the syntax is not as terse an in Haskell, due to the nature of the two languages; in Scala, everything is an object, and Haskell behaviors are simulated using <code>traits</code>. This obviously force the programmer to write code that resemble method invocations. When allowed, I always prefer the “dot-free” syntax (like the example above), because give the code a more functional look.</p>
<h4 id="filterm">filterM</h4>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">filterM ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">List</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">)</span> filterM <span class="op">{</span> x <span class="op">=&gt;</span> <span class="fu">some</span><span class="op">(</span>x <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)}</span> <span class="co">//yields some(List(2))</span></span></code></pre></div>
<p>It would have been nice to have the Haskell’s equivalent of <code>return</code>, but I wasn’t able to find nothing like that in scalaz. If you are aware of something different, please let me know, I will be happy to update this post.</p>
<h3 id="functors">Functors</h3>
<p>Another important tool in the functional programmer belt are functors. They are supported in scalaz too (it’s obvious, because <code>Monads</code> are <code>Functors</code>, so it scalaz supports <code>Monads</code>, why not <code>Functors</code>?). scalaz’s developers have decided to polish a bit the syntax, so you have to call <code>map</code> instead of <code>fmap</code>. You may or may not like this choice:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">some</span><span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="fu">map</span> <span class="op">(</span>x <span class="op">=&gt;</span> x <span class="op">*</span> x<span class="op">)</span> <span class="co">//yields some(4)</span></span></code></pre></div>
<h3 id="applicative">Applicative</h3>
<p>In layman’s terms, we can call an <code>Applicative</code> a <code>Functor</code> on steroid. In Haskell, it’s very common to use them to aggregate results of a non-deterministic computation. Take a look to this piece of Haskell code, that can be quite mind-blowing for the apprentice functional programmer:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span>) <span class="op">&lt;$&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="op">&lt;*&gt;</span> [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</span></code></pre></div>
<p>This yields all the possible combination of summing the values from the to lists together. In this case we obtain the list <code>[5,6,7,6,7,8,7,8,9]</code>. In Scala, we can obtain the same result with this syntax:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span><span class="bu">List</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">)</span> <span class="op">|</span>@<span class="op">|</span> <span class="bu">List</span><span class="op">(</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span><span class="op">))</span> <span class="op">{</span> _ <span class="op">+</span> _ <span class="op">}</span></span></code></pre></div>
<p>Where <code>|@|</code> yields an <code>ApplicativeBuilder</code> (I’m not enough proficient with scalaz to speculate about this design choice).</p>
<h3 id="monoid">Monoid</h3>
<p>In Haskell, the two most important function every <code>Monoid</code> has are <code>mempty</code> and <code>mappend</code>. In scalaz you have <code>mzero</code> and <code>|+|</code> instead:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mempty</span><span class="ot"> ::</span> (<span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> a</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mappend</span><span class="ot"> ::</span> (<span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mempty</span><span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="co">--returns an empty list</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>] <span class="ot">`mappend`</span> [<span class="dv">3</span>,<span class="dv">4</span>] <span class="co">-- [1,2,3,4]</span></span></code></pre></div>
<p>This is roughly the equivalent in Scala:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>mzero<span class="op">[</span><span class="bu">List</span><span class="op">[</span><span class="bu">Int</span><span class="op">]]</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="bu">List</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">)</span> <span class="op">|+|</span> <span class="bu">List</span><span class="op">(</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">)</span></span></code></pre></div>
<p>Well, I have to say that amoung all the scalaz stuff, the <code>Monoid</code> part is what I like less. Why? Because it doesn’t stick with the original Haskell and matchematical definition. Wolfram MathWorld sais that:</p>
<div class="glance-box">
<p>A monoid is a set that is closed under an associative binary operation and has an identity element[…]</p>
</div>
<p><br></p>
<p>In layman’s terms, every <code>Monoid</code> is defined respect to an operation. This explain why an <code>Int</code> can’t be a <code>Monoid</code> per se: which operation should we consider? <code>+</code> or <code>*</code>? You can prove this trying to ask Haskell for the “zero value” of an <code>Int</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mempty</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">Monoid</span> <span class="dt">Int</span>) <span class="op">...</span></span></code></pre></div>
<p>And the same applies for <code>mappend</code>: how can Haskell know how to append two <code>Int</code>?</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span> <span class="ot">`mappend`</span> <span class="dv">4</span></span></code></pre></div>
<p>To solve this, we wrap our <code>Int</code>(s) in types that are instances of <code>Monoid</code>, for example <code>Sum</code> and <code>Product</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mempty</span><span class="ot"> ::</span> <span class="dt">Sum</span> <span class="dt">Int</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Sum</span> {getSum <span class="ot">=</span> <span class="dv">0</span>}</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="fu">mempty</span><span class="ot"> ::</span> <span class="dt">Product</span> <span class="dt">Int</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Product</span> {getProduct <span class="ot">=</span> <span class="dv">1</span>}</span></code></pre></div>
<p>Now, with this formalism, we can <code>mappend</code> our <code>Monoid</code>, because now we have an operation that characterize the <code>Monoid</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Sum</span> <span class="dv">4</span> <span class="ot">`mappend`</span> <span class="dt">Sum</span> <span class="dv">5</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Sum</span> {getSum <span class="ot">=</span> <span class="dv">9</span>}</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Product</span> <span class="dv">4</span> <span class="ot">`mappend`</span> <span class="dt">Product</span> <span class="dv">4</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Product</span> {getProduct <span class="ot">=</span> <span class="dv">16</span>}</span></code></pre></div>
<p>Conversely, Scala is not so strict, and allows us to do this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dv">9</span> <span class="op">|+|</span> <span class="dv">15</span></span></code></pre></div>
<p>Which I don’t like very much. (To the expert reader? What am I missing? Maybe is <code>|+|</code> an alias for a <code>Monoid</code> closed on <code>+</code>?)</p>
<h3 id="pipelines-and-function-composition">Pipelines and function composition</h3>
<p>This actually isn’t an Haskell features, but for example F# has the nice pipeline operator <code>(|&gt;)</code> to give the code a dataflow structure. You can use the pipeline operator to implement function composition as well:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">floor</span> <span class="op">.</span> <span class="fu">sqrt</span> <span class="op">$</span> <span class="dv">10</span> <span class="co">--equivalent to floor(sqrt(10))</span></span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fl">10.0</span> <span class="op">|&gt;</span> sqrt <span class="op">|&gt;</span> floor <span class="co">//yields 3.0</span></span></code></pre></div>
<p>As you can see, the computation “flows” into two different ways: in the former example from right to left, in the latter from left to right, but the result is the same. A nice that we got for free here is a bit more of type safety: whilst Haskell accept the above code, Scala refuses to compile due to a type mismatch, if we pass <code>10</code> to the pipeline operator. Nice.</p>
<h2 id="conclusions">Conclusions</h2>
<p>This first part was dense, but also useful to get myself acquainted with scalaz. There is still a lot to cover (for example <code>Comonad</code>, <code>Arrow</code> and more), so there is room for a part 2. I think scalaz has a lot of potentials, and I’ll be happy to use in a project if I have the chance. I believe it helps to get rid of the “OO-flavor” Scala inherited from its Java vestiges. Before the farewell, take a look at this two blog post, that I’ve read to gather part of the material from <code>Applicative</code> and <code>Monoid</code>:</p>
<ul>
<li><a href="http://www.casualmiracles.com/2012/01/16/a-small-example-of-applicative-functors-with-scalaz/">A Small Example of Applicative Functors with Scalaz</a></li>
<li><a href="http://voidmainargs.blogspot.it/2012/02/having-fun-with-monoid-in-scalaz-seven.html">Having Fun with Monoid in Scalaz Seven</a></li>
</ul>
<p>Happy hacking!</p>]]></summary>
</entry>

</feed>
